{
  "swagger": "2.0",
  "info": {
    "title": "Crosswork Health Insights API",
    "version": "1.0.0",
    "contact": {
      "name": "Crosswork Team, Cisco",
      "email": "support@cisco.com"
    },
    "license": {
      "name": "Cisco Software License Agreement",
      "url": "http://www.cisco.com/public/sw-license-agreement.html"
    },
    "description": "Crosswork Health Insights (HI) is a software system that provides smart Key Performance Indicator (KPI) monitoring and remediation for service-provider networks. This document contains details of the HI RESTful APIs that can be used to manage KPIs, enable or disable KPIs on tagged groups or Devices, query KPIs and Device alerts, remediate alerting KPIs, and so on."
  },
  "schemes": [
    "https"
  ],
  "basePath": "/crosswork/hi/",
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/v1/kpimgmt/query": {
      "parameters": [
        {
          "name": "body",
          "in": "body",
          "description": "Specify filters to query KPIs",
          "required": false,
          "schema": {
              "$ref": "#/definitions/query_kpis"
            }
        }
      ],
      "post": {
        "summary": "Get the definition of existing KPIs in the system",
        "tags": [
          "QueryKPIs"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/kpis"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpimgmt/write": {
      "post": {
        "summary": "Create new custom, user-defined KPIs. Note that HI supports custom KPIs having only 1 sensor path in the current release.",
        "tags": [
          "CreateKPIs"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Definition of a set of KPIs",
            "required": true,
            "schema": {
              "$ref": "#/definitions/kpis_post"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Created. The request was successful. One or more new resources were created."
          },
          "400": {
            "description": "Bad Request. The request is malformed in some way and the server cannot process it."
          },
          "409": {
            "description": "Conflict: The request could not be completed due to a conflict with the current state of the target resource. For example: KPI already exists."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
        },
        "patch": {
          "summary": "Patch properties of an existing user-defined KPI. If the KPI is associated with a Device, the update is not allowed.",
          "tags": [
            "PatchKPIs"
          ],
          "parameters": [
            {
              "in": "body",
              "name": "body",
              "description": "Definition of a set of KPIs",
              "required": true,
              "schema": {
                "$ref": "#/definitions/kpis_patch"
              }
            }
          ],
          "responses": {
            "200": {
              "description": "OK. The request was successful. The result is contained in the response body."
            },
            "400": {
              "description": "Bad Request. The request is malformed in some way and the server cannot process it.  For example: The KPI in the request does not exist (is not defined)."
            },
            "404": {
              "description": "Not Found. The client made a request for a resource that does not exist. For example: The specified KPI was not found."
            },
            "409": {
              "description": "Conflict: The request could not be completed due to a conflict with the current state of the target resource. For example: KPI already applied to Device(s), cannot patch."
            },
            "500": {
              "description": "Internal Server Error. The server could not fulfill the request.",
              "schema": {
                "$ref": "#/definitions/error"
              }
            }
          }
         }
    },
    "/v1/kpimgmt/delete": {
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "List of user defined KPIs (kpi_id) to be deleted.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/delete_kpis"
            }
          }
        ],
      "post": {
        "summary": "Delete specified KPIs. If a KPI is associated with a Device, delete is not allowed.",
        "tags": [
          "DeleteKPI"
        ],
        "responses": {
          "204": {
            "description": "No Content. The request was successful and there is no additional content in the response body."
          },
          "400": {
            "description": "Bad Request. The request is malformed in some way and the server cannot process it. For example: The specified KPI is not user-defined."
          },
          "409": {
            "description": "Conflict: The request could not be completed due to a conflict with the current state of the target resource. For example: KPI already applied to Device(s), cannot delete."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
       }
     },
    "/v1/kpiassoc/query": {
      "parameters": [
        {
          "name": "body",
          "in": "body",
          "description": "Specify filters to query KPIs applied to Devices or tagged groups",
          "required": true,
          "schema": {
              "$ref": "#/definitions/query_kpi_devices"
            }
        }
      ],
      "post": {
        "summary": "Get all or specific KPIs that have been applied to Devices or tagged groups",
	"description": "If details of all KPIs applied to a Device (including tick and parameters) are desired, then pass a single Device host name to the API. When a single Device is passed to the API, it returns complete details of each KPI applied to the Device. If a list of all KPIs applied to a set of Devices or groups is desired, then pass the complete set of Devices or Device Tags to the API. When multiple Devices or Tags are passed to the API, it returns a list of KPIs applied to each Device passed in.",
        "tags": [
          "QueryKPIDevices"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/devices"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpiassoc/write": {
      "post": {
        "summary": "Apply KPIs to Devices or groups",
        "tags": [
          "EnableKPIDevice"
        ],
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "A set of KPIs associated with a set of Devices or tagged groups. Pass kpiDevices or kpiGroups in any given request, not both. ",
            "required": true,
            "schema": {
              "$ref": "#/definitions/post_kpi_devices"
            }
          }
        ],
        "responses": {
          "201": {
            "description": "Created. The request was successful. One or more new resources were created."
          },
          "400": {
            "description": "Bad Request. The request is malformed in some way and the server cannot process it. For example: Only one of kpiDevices OR kpiGroups should be passed to enable KPIs on Devices or groups"
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpiassoc/delete": {
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "Expects either a list of KPI IDs or a list of valid Devices or Device Tags.",
            "required": true,
            "schema": {
              "$ref": "#/definitions/delete_kpi_devices"
            }
          }
        ],
      "post": {
        "summary": "Delete KPIs applied to Devices or groups. The HI system performs <best effort> deletes.",
        "tags": [
          "DeleteKPIDevice"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpimgmt/import": {
      "post": {
        "summary": "Post the tarball through multipart/form-data HTTP",
        "consumes": [
	  "multipart/form-data"
	],
        "tags": [
          "ImportKPIs"
        ],
        "parameters": [
          {
            "in": "formData",
            "name": "file",
            "description": "A multipart HTTP form containing a tgz/tar.gz (a gzipped tarball) of KPIs and their tick and dashboard files",
            "type": "file"
          }
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body."
          },
          "400": {
            "description": "Bad Request. The request is malformed in some way and the server cannot process it."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpimgmt/export": {
        "parameters": [
          {
            "in": "body",
            "name": "body",
            "description": "A multi-part HTTP form containing a tgz/tar.gz (a gzipped tarball) ",
            "required": true,
            "schema": {
              "$ref": "#/definitions/export_kpis"
            }
          }
        ],
      "post": {
        "summary": "Export KPIs installed on the HI system",
	"produces": ["application/gzip"],
        "tags": [
          "ExportKPIs"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body. For example: \"Base64 encoded string containing zipped tarball with KPI definitions and associated files.\""
          },
          "400": {
            "description": "Bad Request. The request is malformed in some way and the server cannot process it."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/alerts/device/deviceTags": {
      "post": {
        "summary": "Retrieve a Device-centric view of alerts for Device Tags.",
	"description": "Response is returned as an array of DeviceAlerts. The API currently supports retrieving all alerts for specified Device Tags and can be filtered by alert levels, KPIs and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. The API can be used to return a sorted list of Devices by number of alerts in the specified duration by passing the top_devices request parameter as true. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsDeviceTags",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsDevViewResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsDevTagsReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/device/devices": {
      "post": {
        "summary": "KPI Alerts related API endpoints. Retrieve a Device-centric view of alerts for Devices.",
	"description": "Response is returned as an array of DeviceAlerts. The API currently supports retrieving all alerts for specified Devices and can be filtered by alert levels, KPIs and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. The API can be used to return a sorted list of Devices by number of alerts in the specified duration by passing the top_devices request parameter as true. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsDevices",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsDevViewResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsDevReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/kpi/deviceTags": {
      "post": {
        "summary": "Retrieve a KPI-centric view of alerts for KPIs and Device tags. ",
	"description": "Response is returned as an array of KpiAlerts. The API currently supports retrieving all alerts for specified KPIs and Device Tags and can be filtered by alert levels and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. The API can be used to return a sorted list of Devices by number of alerts in the specified duration by passing the top_devices request parameter as true. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsKpiDeviceTags",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsKpiViewResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsKpiDevTagsReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/kpi/devices": {
      "post": {
        "summary": "Retrieve a KPI-centric view of alerts for KPIs and Devices. ",
	"description": "Response is returned as an array of KpiAlerts. The API currently supports retrieving all alerts for specified KPIs and Devices and can be filtered by alert levels and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. The API can be used to return a sorted list of Devices by number of alerts in the specified duration by passing the top_Devices request parameter as true. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsKpiDevices",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsKpiViewResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsKpiDevReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/alerts/deviceTags": {
      "post": {
        "summary": "Retrieve raw time series of raw alerts for Device Tags in descending order.",
	"description": "Response is returned in a time series format. The API currently supports retrieving all alerts for specified KPIs and Device Tags and can be filtered by alert levels and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsRawDeviceTags",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsTimeSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesDtlTagsReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/alerts/devices": {
      "post": {
        "summary": "Retrieve raw time series of raw alerts for Devices in descending order.",
	"description": "Response is returned in a time series format. The API currently supports retrieving all alerts for specified KPIs and Devices and can be filtered by alert levels and time duration. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return alerts by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsRawDevices",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsTimeSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesDtlReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/Device": {
      "post": {
        "summary": "Retrieve raw time series of a summary view of Impacted Devices (Crosswork UI landing page).",
	"description": "Response is returned in a time series format. The API retrieves a time series of the count of any new Devices that received alerts in Critical and Major severity in the past minute during the past one hour only. A maximum total of 60 time series data points can be retrieved from this API. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return data by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsDeviceSummary",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsTimeSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesSummaryReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/kpi": {
      "post": {
        "summary": "Retrieve raw time series of a summary view of Impacted KPIs (Crosswork UI landing page).",
	"description": "Response is returned in a time series format. The API retrieves a time series of the count of any new KPIs that received alerts in Critical and Major severity in the past minute during past one hour only.  A maximum total of 60 time series data points can be retrieved from this API. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return data by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsKpiSummary",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsTimeSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesSummaryReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/levels/deviceTags": {
      "post": {
        "summary": "Retrieve a time series of count of alerts by levels for each specified time interval for Device Tags.",
	"description": "Used by bar charts in the Pulse UI. Response is returned as an array of AlertSummaryTS format. The API currently supports retrieving all alerts for specified KPIs and Device Tags and can be filtered by alert levels and time duration. If no Device Tags or KPIs are passed in, the API will aggregate all alerts in the time interval, irrespective of specific Devices or KPIs. The API also accepts a groupby argument, where the grouping time interval should be specified as required. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return the alert count by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsSeriesLevelsDeviceTags",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesLevelsDevTagsReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/alerts/series/levels/devices": {
      "post": {
        "summary": "Retrieve a time series of count of alerts by levels for each specified time interval for Devices.",
	"description": "Used by bar charts in the Pulse UI. Response is returned as an array of AlertSummaryTS format. The API currently supports retrieving all alerts for specified KPIs and Devices and can be filtered by alert levels and time duration. If no Devices or KPIs are passed in, the API will aggregate all alerts in the time interval irrespective of specific Devices or KPIs. The API also accepts a groupby argument, where the grouping time interval should be specified as required. Pagination is supported by specifying limit and offset in the POST request arguments. If no filter parameters are passed to the query endpoints, the API will return the alert count by applying the default limit of 50 and default time interval of one hour.",
        "operationId": "GetAlertsSeriesLevelsDevice",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesResp"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/pulseAlertsSeriesLevelsDevReq"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/v1/recommendation/kpi/devices/{device_id}": {
      "parameters": [
        {
          "name": "device_id",
          "in": "path",
          "description": "Device identifier",
          "required": true,
          "type": "string"
        }
      ],
      "get": {
        "summary": "Get recommended KPIs of the specified Device based on the Device type, and the Device hardware and software configurations. A KPI is recommended if the value of the property 'recommend' is true.",
        "tags": [
          "RecommendKPIs"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "type": "object",
              "properties": {
                "kpis": {
                  "type": "object",
                  "properties": {
                    "kpi": {
                      "type": "array",
                      "items": {
                        "properties": {
                          "kpi_id": {
                            "type": "string",
                            "description": "KPI identifier"
                          },
                          "kpi_name": {
                            "type": "string",
                            "description": "The KPI display name has a maximum length of 64 characters."
                          },
                          "category": {
                            "type": "string",
                            "description": "The KPI category has a maximum length of 64 characters."
                          },
                          "summary": {
                            "type": "string",
                            "description": "Brief one-line description of the KPI"
                          },
                          "details": {
                            "type": "string",
                            "description": "Detailed description of the KPI"
                          },
                          "formula": {
                            "type": "string",
                            "description": "Optional: KPI formula encoded in base64"
                          },
                          "recommend": {
                            "type": "boolean",
                            "description": "A value of 'true' indicates that this KPI is recommended."
                          },
                          "paths": {
                            "type": "object",
                            "properties": {
                              "path": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/definitions/path"
                                }
                              }
                            }
                          },
                          "scripts": {
                            "type": "object",
                            "properties": {
                              "script": {
                                "type": "array",
                                "items": {
                                  "$ref": "#/definitions/script"
                                }
                              }
                            }
                          }
                        },
                        "required": [
                          "kpi_id",
                          "kpi_name",
                          "category",
                          "summary",
                          "details",
                          "paths"
                        ]
                      }
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found. The client made a request for a resource that does not exist. For example: The specified Device was not found."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpi/transactions": {
      "get": {
        "summary": "Retrieve the last 'n' transactions, specified by limit. Pagination is supported by specifying limit and offset in the request parameters.",
      "parameters": [
        {
          "name": "limit",
          "in": "query",
          "description": "Number of transactions to be returned by the API",
          "required": false,
          "type": "integer"
        },
        {
          "name": "offset",
          "in": "query",
          "description": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on.",
          "required": false,
          "type": "integer"
        },
        {
          "name": "state",
          "in": "query",
          "description": "Optional filter to specify the state of the transactions to be retrieved by the API. Valid values are Processing, Success, Partial and Failed.",
          "required": false,
          "type": "string"
        }
      ],
        "tags": [
          "Transactions"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/transactions"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/kpi/transactions/{txid}": {
      "parameters": [
        {
          "name": "txid",
          "in": "path",
          "description": "Transaction identifier (64-bit integer)",
          "required": true,
          "type": "integer"
        }
      ],
      "get": {
        "summary": "Get a specific transaction.",
        "tags": [
          "Transactions"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "type": "object",
              "properties": {
                "transaction": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/transaction"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Not Found. The client made a request for a resource that does not exist."
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
    "/v1/alerts/remediation": {
      "parameters": [
        {
          "name": "body",
          "in": "body",
          "description": "Specify parameters to remediate an alerting KPI",
          "required": false,
          "schema": {
              "$ref": "#/definitions/remediation"
            }
        }
      ],
      "post": {
        "summary": "Remediate an alerting KPI",
        "tags": [
          "Remediation"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/remediate"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
   "/v1/kpimgmt/link": {
      "parameters": [
        {
          "name": "body",
          "in": "body",
          "description": "Associate remediation with a KPI",
          "required": false,
          "schema": {
              "$ref": "#/definitions/link"
            }
        }
      ],
      "post": {
        "summary": "Associate remediation with a KPI",
        "tags": [
          "Remediation"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/link"
            }
          },
          "201": {
            "description": " If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on.",
            "schema": {
              "$ref": "#/definitions/link"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    },
   "/v1/kpimgmt/unlink": {
      "parameters": [
        {
          "name": "body",
          "in": "body",
          "description": "Remove Remediation associated with a KPI",
          "required": false,
          "schema": {
              "$ref": "#/definitions/link"
            }
        }
      ],
      "post": {
        "summary": "To remove Remediation associated with a KPI",
        "tags": [
          "Remediation"
        ],
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body.",
            "schema": {
              "$ref": "#/definitions/link"
            }
          },
          "201": {
            "description": "Created. The request was successful. One or more new resources were created.",
            "schema": {
              "$ref": "#/definitions/link"
            }
          },
          "500": {
            "description": "Internal Server Error. The server could not fulfill the request.",
            "schema": {
              "$ref": "#/definitions/error"
            }
          }
        }
      }
    }
  },
  "securityDefinitions": {
    "bearerAuth": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "security": [{
    "bearerAuth": []
  }],
  "definitions": {
    "kpis_post":  {
      "type": "object",
      "properties": {
         "kpiPost":  {
          "type": "object",
          "description": "Contains a set of KPI definitions",
           "properties": {
           "kpis": {
           "type": "object",
           "properties": {
            "kpi": {
              "type": "array",
              "items": {
      	      "properties": {
        "kpi_id": {
          "type": "string",
          "description": "KPI identifier. The ID can have a maximum length of 64 upper or lowercase alphanumeric characters, and can include underscores. It must not contain \"cisco\" or \"pulse\" prefixes."
        },
        "kpi_name": {
          "type": "string",
          "description": "The KPI display name has a maximum length of 64 characters."
        },
        "state": {
          "type": "string",
          "description": "KPI state, with values of 'pending' and 'complete'. To set to state 'complete', all fields must be specified. Only a KPI in state 'complete' can be associated to a Device."
        },
        "category": {
          "type": "string",
          "description": "The KPI category has a maximum length of 64 characters."
        },
        "summary": {
          "type": "string",
          "description": "A brief one-line description of the KPI. It has a maximum length of 256 characters."
        },
        "details": {
          "type": "string",
          "description": "A detailed description of the KPI. It has a maximum length of 1024 characters."
        },
        "sensor_groups": {
          "type": "object",
          "properties": {
            "sensor_group": {
              "type": "array",
              "description": "Support only one sensor group",
              "items": {
                "$ref": "#/definitions/define_sensor_group"
              }
            }
          }
        },
        "scripts": {
          "type": "object",
          "properties": {
            "script": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_script"
              }
            }
          }
        },
        "dashboards": {
          "type": "object",
          "properties": {
            "dashboard": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_dashboard"
              }
            }
          }
        }
      },
      "example": {
        "state": "complete",
        "kpi_id": "wizard_test_cpu_utilization",
        "kpi_name": "Wizard Test Cpu Utilization",
        "category": "User Created",
        "summary": "Monitor CPU usage across RP and Linecards on Routers",
        "details": "Monitor CPU usage across RP and Linecards on Routers. Alerts are generated when CPU utilization exceeds thresholds.",
        "sensor_groups": {
          "sensor_group": [
            {
              "cadence": {
                  "default":   5,
                  "min":       1,
                  "max":       30,
                  "increment": 1
              },
              "sensor_paths": {
                "sensor_path": [
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-five-minute"
                  }
                ]
              }
            }
          ]
        },
        "scripts": {
          "script": [
            {
              "script_id": "Wizard_Test_Cpu_Utilizatione336023b_5efada29e05d_template.tick",
              "script": "//-----------------------------------------------------------------------------\n// This TickScript detects spikes and drops in measured values by alerting when\n// values deviate some number of standard deviations away from normal values.\n// Threshold for number of standard deviations can be set in the var\n// 'alert_threshold'.\n//\n// References:\n// - https://docs.influxdata.com/influxdb/v1.3/\n// - https://docs.influxdata.com/kapacitor/v1.3/\n//\n// Copyright (c) 2017 by Cisco\n// All rights reserved.\n//-----------------------------------------------------------------------------\n\n// PULSE_RUN_TIME InfluxDB DB to write alerts to.\nvar alerts_db = 'robot_alertdb'\n\n// PULSE_RUN_TIME InfluxDB measurement.\nvar alerts_measurement = 'alerts'\n\n// PULSE_RUN_TIME InfluxDB retention policy.\nvar alerts_rp = 'rp1h_1'\n\n// PULSE_RUN_TIME Data producer.\nvar producer string\n\n// KPI_INTERNAL ID of KPI that this TICKScript corresponds to.\nvar kpi_id = 'pulse_custom_KPI'\n\n// KPI_INTERNAL ID of the alert.\nvar alert_id = 'pulse_custom_KPI'\n\n// KPI_INTERNAL Alert message.\nvar alert_message = '{{ .Level }} : data {{ index .Fields \"kpi_stream\" | printf \"%0.2f\" }} % is Unusual, Threshold: {{ index .Fields \"alert_threshold\" | printf \"%0.2f\" }} SD. It is {{ index .Fields \"sigma\" | printf \"%0.2f\"}} std. dev away from Average.'\n\n// KPI_INTERNAL ID of alert clear events.\nvar clear_id = 'pulse_custom_KPI'\n\n// KPI_INTERNAL Clear message.\nvar clear_message = '{{ .Level }} : data {{ index .Fields \"kpi_stream\" | printf \"%0.2f\" }} % has returned to Usual range, Threshold: {{ index .Fields \"clear_threshold\" | printf \"%0.2f\" }} SD. It is {{ index .Fields \"sigma\" | printf \"%0.2f\"}} std. dev away from Average.'\n\n// KPI_INTERNAL InfluxDB measurement to retrieve data from.\nvar measurement = 'pulse_customer_measurement'\n\n// KPI_INTERNAL Filter expression that filters on data stream.\nvar where_filter = lambda: TRUE\n\n// KPI_INTERNAL Producer filter.\nvar where_producer = lambda: \"Producer\" == producer\n\n// KPI_INTERNAL Group by.\nvar groups = [*]\n\n// KPI_INTERNAL Lambda expression to reduce raw data to KPI.\nvar stream_eval_lambda = lambda: float(\"field\")\n\n// KPI_THRESHOLDS Alert threshold in term of number of standard deviations from the mean.\nvar alert_threshold = 2.00\n\n// KPI_THRESHOLDS Time in seconds after entering alert state to begin sending CRITICAL alerts.\nvar alert_crit_time = 0.00\n\n// KPI_THRESHOLDS Time in seconds after entering alert state to begin sending WARNING alerts.\nvar alert_warn_time = 0.00\n\n// KPI_THRESHOLDS Clear threshold in term of number of standard deviations from the mean.\nvar clear_threshold = 2.00\n\n// KPI_THRESHOLDS Time in seconds after entering clear state to begin sending CLEAR alerts.\nvar clear_time = 0.00\n\n// KPI_INTERNAL Unit of time for alerts.\nvar time_unit = 1s\n\n// KPI_INTERNAL Three times the cadence of measurement data.\nvar three_times_cadence = 1m30s\n\nvar data = stream\n    |from()\n        .measurement(measurement)\n        .where(where_producer)\n        .where(where_filter)\n        .groupBy(groups)\n    |httpOut('data')\n\n// Log and alert if sample rate is not above minimum threshold.\nvar deadman_data = data\n    |deadman(1.0, three_times_cadence)\n        .log('/var/log/robot/alert.log')\n    |httpOut('deadman_data')\n\n// kpi_stream that is result of stream_eval_lambda applied to raw data.\nvar transform = data\n    |eval(stream_eval_lambda)\n        .as('kpi_stream')\n    |httpOut('transform')\n\nvar deadman_transform = transform\n    |deadman(1.0, three_times_cadence)\n        .log('/var/log/robot/alert.log')\n    |httpOut('deadman_transform')\n\n// Identify how many standard deviations away the sample is from the mean and\n// keep track of how long is in alert or clear condition.\nvar stream_sd = transform\n    |eval(lambda: sigma(\"kpi_stream\"))\n        .as('sigma')\n        .keep('kpi_stream', 'sigma')\n    |httpOut('stream_sd')\n    |stateDuration(lambda: \"sigma\" >= alert_threshold)\n                    .unit(time_unit)\n                    .as('alert_duration')\n    |stateDuration(lambda: \"sigma\" < clear_threshold)\n                    .unit(time_unit)\n                    .as('clear_duration')\n    |default()\n        .field('alert_threshold', alert_threshold)\n        .field('clear_threshold', clear_threshold)\n        .tag('kpi_id', kpi_id)\n        .field('alert_src', 'TICK')\n    |httpOut('final_alert_data')\n\n// Critical and warning alerts.\nstream_sd\n    |alert()\n         .warn(lambda: \"alert_duration\" >= alert_warn_time)\n         .crit(lambda: \"alert_duration\" >= alert_crit_time)\n         .stateChangesOnly()\n         //.critReset(lambda: \"clear_duration\" >= clear_time)\n         .log('/var/log/robot/alert.log')\n         .levelTag('level')\n         .id(alert_id)\n         .idField('id')\n         .message(alert_message)\n         .messageField('msg')\n    |where(lambda: \"level\" != 'OK')\n    |influxDBOut()\n        .database(alerts_db)\n        .retentionPolicy(alerts_rp)\n        .measurement(alerts_measurement)\n        .tag('state', 'alert')\n\n// Clear alerts.\nstream_sd\n    |alert()\n         .info(lambda: \"clear_duration\" >= clear_time)\n         .stateChangesOnly()\n         .levelTag('level')\n         .id(clear_id)\n         .idField('id')\n         .message(clear_message)\n         .messageField('msg')\n    |where(lambda: \"level\" != 'OK')\n    |influxDBOut()\n         .database(alerts_db)\n         .retentionPolicy(alerts_rp)\n         .measurement(alerts_measurement)\n         .tag('state', 'clear')\n"
            }
          ]
        },
        "dashboards": {
          "dashboard": [
            {
              "body": {
                "dashboard": {
                  "annotations": {
                    "enable": false,
                    "list": null
                  },
                  "editable": true,
                  "refresh": "",
                  "rows": null,
                  "style": "",
                  "tags": null,
                  "templating": {
                    "list": null
                  },
                  "time": {
                    "from": "",
                    "now": false,
                    "to": ""
                  },
                  "timezone": "",
                  "title": "Wizard_Test_Cpu_Utilizatione336023b_5efada29e05d",
                  "version": 0
                }
              }
            }
          ]
        }
          }
       }
       }
       }
            }
            }
            }
            }
        },
    "kpis_patch": {
      "type": "object",
      "properties": {
         "kpiPatch":  {
          "type": "object",
          "description": "Contains a set of user-defined KPIs to be partially patched",
          "properties": {
            "kpi": {
              "type": "array",
              "items": {
      	      "properties": {
        "kpi_id": {
          "type": "string",
          "description": "KPI identifier. The ID can have a maximum length of 64 upper or lowercase alphanumeric characters, and can include underscores. It must not contain \"cisco\" or \"pulse\" prefixes."
        },
        "kpi_name": {
          "type": "string",
          "description": "The KPI display name has a maximum length of 64 characters."
        },
        "state": {
          "type": "string",
          "description": "KPI state, with values of 'pending' and 'complete'. To set to state 'complete', all fields must be specified. Only a KPI in state 'complete' can be associated to a Device."
        },
        "category": {
          "type": "string",
          "description": "The KPI category has a maximum length of 64 characters."
        },
        "summary": {
          "type": "string",
          "description": "A brief, one-line description of the KPI, with a maximum length of 256 characters."
        },
        "details": {
          "type": "string",
          "description": "A detailed description of the KPI, with a maximum length of 1024 characters."
        },
        "sensor_groups": {
          "type": "object",
          "properties": {
            "sensor_group": {
              "type": "array",
              "description": "Support only one sensor group",
              "items": {
                "$ref": "#/definitions/define_sensor_group"
              }
            }
          }
        },
        "scripts": {
          "type": "object",
          "properties": {
            "script": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_script"
              }
            }
          }
        },
        "dashboards": {
          "type": "object",
          "properties": {
            "dashboard": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_dashboard"
              }
            }
          }
        }
      },
      "example": {
                "kpi_id": "wizard_test_cpu_utilization",
                "kpi_name": "CPU threshold Patch",
                "summary": "Monitor CPU usage across RP and Linecards on Routers test patch",
                "details": "Patch Monitor CPU usage across RP and Linecards on routers. Alerts are generated when CPU utilization exceeds thresholds.",
                "sensor_groups": {
                  "sensor_group": [
                    {
                      "cadence": {
                          "default":   5,
                          "min":       1,
                          "max":       30,
                          "increment": 1
                      },
                      "sensor_paths": {
                        "sensor_path": [
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-one-minute"
                          },
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-five-minute"
                          },
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-fifteen-minute"
                          },
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-one-minute"
                          },
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-five-minute"
                          },
                          {
                            "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-fifteen-minute"
                          }
                        ]
                      }
                    }
                  ]
                },
                "dashboards": {
                  "dashboard": [
                    {
                      "body": {
                        "dashboard": {
                          "annotations": {
                            "enable": true,
                            "list": null
                          },
                          "editable": true,
                          "refresh": "",
                          "rows": null,
                          "style": "",
                          "tags": null,
                          "templating": {
                            "list": null
                          },
                          "time": {
                            "from": "",
                            "now": false,
                            "to": ""
                          },
                          "timezone": "",
                          "title": "Test_Cpu_Utilization",
                          "version": 0
                        }
                      }
                    }
                  ]
                }
          }
       }
       }
            }
            }
            }
        },
    "query_kpis":  {
      "type": "object",
      "properties": {
        "kpis": {
          "type": "array",
          "description": "Array of strings that specify KPI IDs to be queried",
          "items": {
            "type": "string"
          }
        },
        "limit": {
          "type": "integer",
          "description": "Specifies the number of records to be fetched in each API call"
        },
        "offset": {
          "type": "integer",
          "description": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        }
      },
      "example": {
        "kpis": ["pulse_cpu_utilization"],
	"limit": 1,
	"offset": 0
      }
    },
    "delete_kpis":  {
      "type": "object",
      "properties": {
        "kpis": {
          "type": "array",
          "description": "Array of strings that specify KPI IDs to be deleted",
          "items": {
            "type": "string"
          }
        }
      },
      "example": {
        "kpis": ["wizard_test_cpu_utilization"]
      }
    },
    "query_kpi_devices": {
      "type": "object",
      "properties": {
        "kpis": {
          "type": "array",
          "description": "Array of strings that specify KPI names to be queried",
          "items": {
            "type": "string"
          }
        },
        "devices": {
          "type": "array",
          "description": "Array of strings that specify Devices to be queried",
          "items": {
            "type": "string"
          }
        },
        "tags": {
          "type": "array",
          "description": "Array of strings that specify Tags (groups) to be queried",
          "items": {
            "type": "string"
          }
        },
        "limit": {
          "type": "integer",
          "description": "Specifies the number of records to be fetched in each API call. Default limit is 1."
        },
        "offset": {
          "type": "integer",
          "description": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        }
      },
      "example": {
        "kpis": ["pulse_cpu_utilization","pulse_cpu_threshold"],
        "tags": ["cli","demo"],
        "limit": 5,
        "offset": 0
      }
    },
    "post_kpi_devices": {
      "type": "object",
      "properties": {
        "kpiDevices": {
          "type": "object",
          "description": "Contains a set of Devices and KPIs to be applied. NOTE: Either kpiDevices pr kpiGroups, not both, should be passed in a given request. The example below shows data in both kpiDevices and kpiGroups in order to depict how to pass values to the API. However, only one of these needs to be populated.",
          "properties": {
            "devices": {
              "type": "object",
              "properties": {
                "Device": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/Device"
                  }
                }
              }
            }
          }
        },
        "kpiGroups": {
          "type": "object",
          "description": "Contains a set of groups and KPIs to be applied. NOTE: Either kpiDevices pr kpiGroups, not both, should be passed in a given request.",
          "properties": {
            "groups": {
              "type": "object",
              "properties": {
                "group": {
                  "type": "array",
                  "items": {
                    "$ref": "#/definitions/group"
                  }
                }
              }
            }
          }
        }
      },
      "example": {
         "kpiGroups": {
           "groups": {
             "group": [
               {
                 "group_id": "cli",
                 "kpis": {
                   "kpi": [
                      {
                       "kpi_id": "pulse_cpu_threshold",
                       "scripts": {
                         "script": [
                           {
                             "script_id": "pulse_cpu_threshold_template.tick",
                             "script": "",
                                 "parameters": {
                                        "parameter": [
                                 {
                                   "name": "level2_severity",
                                   "type": "string",
                                   "value": "MAJOR",
                                   "display_name": "Level 2 Alert Severity",
                                   "possible_values": [
                                     "MINOR",
                                     "MAJOR",
                                     "WARNING",
                                     "CRITICAL"
                                   ]
                                 },
                                 {
                                   "name": "level2_threshold",
                                   "type": "float",
                                   "value": "70.0",
                                   "display_name": "Level 2 Alert Threshold",
                                   "possible_values": []
                                 },
                                 {
                                   "name": "level2_time",
                                   "type": "float",
                                   "value": "0.0",
                                   "display_name": "Level 2 Alert Time",
                                   "possible_values": []
                                 },
                                 {
                                   "name": "level1_severity",
                                   "type": "string",
                                   "value": "WARNING",
                                   "display_name": "Level 1 Alert Severity",
                                   "possible_values": [
                                     "MINOR",
                                     "MAJOR",
                                     "WARNING",
                                     "CRITICAL"
                                   ]
                                 },
                                 {
                                   "name": "level1_threshold",
                                   "type": "float",
                                   "value": "48.0",
                                   "display_name": "Level 1 Alert Threshold",
                                   "possible_values": []
                                 },
                                 {
                                   "name": "level1_time",
                                   "type": "float",
                                   "value": "0.0",
                                   "display_name": "Level 1 Alert Time",
                                   "possible_values": []
                                 },
                                 {
                                   "name": "clear_time",
                                   "type": "float",
                                   "value": "0.0",
                                   "display_name": "Clear Time",
                                   "possible_values": []
                                 }
                               ]
                             }
                           }
                         ]
                       },
                       "cadence": 5
                     }
                   ]
                 }
               }
             ]
           }
         }
       }
    },
    "delete_kpi_devices": {
      "type": "object",
      "properties": {
        "kpis": {
          "type": "array",
          "description": "Array of strings that specify KPI IDs to be removed from Devices or groups",
          "items": {
            "type": "string"
          }
        },
        "devices": {
          "type": "array",
          "description": "Array of strings that specify Devices where KPIs need to be removed. NOTE: Either Devices or Tags, not both, should be passed in a given request.",
          "items": {
            "type": "string"
          }
        },
        "tags": {
          "type": "array",
          "description": "Array of strings that specify Tags (groups) where KPIs need to be removed. NOTE: Either Devices or Tags, not both, should be passed in a given request.",
          "items": {
            "type": "string"
          }
        }
      },
      "example": {
        "kpis": ["pulse_cpu_utilization","pulse_cpu_threshold"],
        "tags": ["cli"]
      }
    },
    "export_kpis": {
      "type": "object",
      "properties": {
        "kpis": {
          "type": "array",
          "description": "Array of strings that specify KPI IDs to be exported",
          "items": {
            "type": "string"
          }
        }
      },
      "example": {
        "kpis": ["pulse_cpu_utilization","pulse_cpu_threshold"]
      }
    },
    "devices": {
      "type": "object",
      "properties": {
        "devices": {
          "type": "object",
          "properties": {
            "Device": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/Device"
              }
            }
          }
        }
      }
    },
    "group": {
      "type": "object",
      "properties": {
        "group_id": {
          "type": "string",
          "description": "Group identifier"
        },
        "kpis": {
          "type": "object",
          "properties": {
            "kpi": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kpi"
              }
            }
          }
        }
      },
      "required": [
        "group_id",
        "kpis"
      ],
      "example": {
        "group_id": "cli",
        "kpis": {
          "kpi": [
            {
              "kpi_id": "pulse_cpu_utilization",
              "scripts": {
                "script": [
                  {
                    "script_id": "cpu_util_alert_template.tick",
                    "parameters": {
                      "parameter": [
                        {
                          "name": "threshold",
                          "type": "int",
                          "value": "20"
                        },
                        {
                          "name": "alertDB",
                          "type": "string",
                          "value": "robot_alertdb"
                        },
                        {
                          "name": "alertMeasurement",
                          "type": "string",
                          "value": "alerts"
                        }
                      ]
                    }
                  }
                ]
              },
              "cadence": 5
            }
          ]
        }
      }
    },
    "Device": {
      "type": "object",
      "properties": {
        "device_id": {
          "type": "string",
          "description": "Device identifier"
        },
        "kpis": {
          "type": "object",
          "properties": {
            "kpi": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/kpi"
              }
            }
          }
        }
      },
      "required": [
        "device_id",
        "kpis"
      ],
      "example": {
        "device_id": "RouterSFO",
        "kpis": {
          "kpi": [
            {
              "kpi_id": "pulse_cpu_utilization",
              "scripts": {
                "script": [
                  {
                    "script_id": "cpu_util_alert_template.tick",
                    "parameters": {
                      "parameter": [
                        {
                          "name": "threshold",
                          "type": "int",
                          "value": "20"
                        },
                        {
                          "name": "alertDB",
                          "type": "string",
                          "value": "robot_alertdb"
                        },
                        {
                          "name": "alertMeasurement",
                          "type": "string",
                          "value": "alerts"
                        }
                      ]
                    }
                  }
                ]
              },
              "cadence": 5
            }
          ]
        }
      }
    },
    "kpi": {
      "type": "object",
      "properties": {
        "kpi_id": {
          "type": "string",
          "description": "KPI identifier"
        },
        "kpi_name": {
          "type": "string",
          "description": "The KPI display name has a maximum length of 64 characters."
        },
        "category": {
          "type": "string",
          "description": "The KPI category has a maximum length of 64 characters."
        },
        "summary": {
          "type": "string",
          "description": "Brief, one-line description of the KPI"
        },
        "details": {
          "type": "string",
          "description": "Detailed description of the KPI"
        },
        "sensor_groups": {
          "type": "object",
          "properties": {
            "sensor_group": {
              "type": "array",
              "description": "Support only one sensor group.",
              "items": {
                "$ref": "#/definitions/define_sensor_group"
              }
            }
          }
        },
        "paths": {
          "type": "object",
          "properties": {
            "path": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/path"
              }
            }
          }
        },
        "scripts": {
          "type": "object",
          "properties": {
            "script": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/script"
              }
            }
          }
        },
        "dashboards": {
          "type": "object",
          "properties": {
            "dashboard": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/dashboard"
              }
            }
          }
        },
        "cadence": {
          "type": "integer",
          "description": "The cadence for telemetry data collection, in minutes."
        }
      },
      "required": [
        "kpi_id",
        "kpi_name",
        "category",
        "summary",
        "details",
        "paths"
      ],
      "example": {
        "kpi_id": "cpu-util",
        "kpi_name": "CPU utilization",
        "category": "CPU",
        "summary": "Monitor CPU usage across RP and linecards on routers",
        "details": "Monitor CPU usage across RP and linecards on routers. Alerts are generated when CPU utilization exceeds thresholds.",
        "paths": {
          "path": [
            {
              "path": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization",
              "cadence": {
                  "default":   5,
                  "min":       1,
                  "max":       30,
                  "increment": 1
              },
              "spec": {
                "fields": [
                  {
                    "name": "node-name",
                    "tag": true
                  },
                  {
                    "name": "total-cpu-one-minute"
                  }
                ]
              }
            }
          ]
        },
        "scripts": {
          "script": [
            {
              "script_id": "cpu_util_alert_template.tick",
              "script": "script_string",
              "parameters": {
                "parameter": [
                  {
                    "name": "alert_threshold",
                    "type": "float",
                    "value": "2.0",
                    "display_name": "Alert Threshold"
                  }
                ]
              }
            }
          ]
        },
        "dashboards": {
          "dashboard": [
            {
              "type": "jsonfile",
              "value": "Pulse-cpu-utilization-summary.json"
            },
            {
              "type": "jsonfile",
              "value": "Pulse-cpu-utilization-raw.json"
            }
          ]
        },
        "cadence": 5
      }
    },
    "kpis": {
      "type": "object",
      "properties": {
        "kpi": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/kpi"
          }
        }
      }
    },
    "patch_kpi": {
      "type": "object",
      "properties": {
        "kpi_id": {
          "type": "string",
          "description": "KPI identifier. The ID can have a maximum length of 64 upper or lowercase alphanumeric characters, and can include underscores. It must not contain \"cisco\" or \"pulse\" prefixes."
        },
        "kpi_name": {
          "type": "string",
          "description": "The KPI display name has a maximum length of 64 characters."
        },
        "state": {
          "type": "string",
          "description": "KPI state, with values of 'pending' and 'complete'. To set to state 'complete', all fields must be specified. Only a KPI in state 'complete' can be associated to a Device."
        },
        "category": {
          "type": "string",
          "description": "The KPI category has a maximum length of 64 characters."
        },
        "summary": {
          "type": "string",
          "description": "A brief, one-line description of the KPI, with a maximum length of 256 characters."
        },
        "details": {
          "type": "string",
          "description": "A detailed description of the KPI, with a maximum length of 1024 characters."
        },
        "sensor_groups": {
          "type": "object",
          "properties": {
            "sensor_group": {
              "type": "array",
              "description": "Support only one sensor group",
              "items": {
                "$ref": "#/definitions/define_sensor_group"
              }
            }
          }
        },
        "scripts": {
          "type": "object",
          "properties": {
            "script": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_script"
              }
            }
          }
        },
        "dashboards": {
          "type": "object",
          "properties": {
            "script": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/define_dashboard"
              }
            }
          }
        }
      },
      "example": {
          "kpiPatch": {
            "kpi": [
              {
        "kpi_id": "wizard_test_cpu_utilization",
        "kpi_name": "CPU threshold Patch",
        "summary": "Monitor CPU usage across RP and Linecards on Routers test patch",
        "details": "Patch Monitor CPU usage across RP and Linecards on Routers. Alerts are generated when CPU utilization exceeds thresholds.",
        "sensor_groups": {
          "sensor_group": [
            {
              "cadence": {
                  "default":   5,
                  "min":       1,
                  "max":       30,
                  "increment": 1
              },
              "sensor_paths": {
                "sensor_path": [
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-one-minute"
                  },
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-five-minute"
                  },
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/total-cpu-fifteen-minute"
                  },
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-one-minute"
                  },
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-five-minute"
                  },
                  {
                    "path_id": "Cisco-IOS-XR-wdsysmon-fd-oper:system-monitoring/cpu-utilization/process-cpu/process-cpu-fifteen-minute"
                  }
                ]
              }
            }
          ]
        },
        "dashboards": {
          "dashboard": [
            {
              "body": {
                "dashboard": {
                  "annotations": {
                    "enable": true,
                    "list": null
                  },
                  "editable": true,
                  "refresh": "",
                  "rows": null,
                  "style": "",
                  "tags": null,
                  "templating": {
                    "list": null
                  },
                  "time": {
                    "from": "",
                    "now": false,
                    "to": ""
                  },
                  "timezone": "",
                  "title": "Wizard_Test_Cpu_Utilizatione336023b_5efada29e05d",
                  "version": 0
                }
              }
            }
          ]
        }
       }
      ]
     }
    }
    },
    "define_script": {
      "type": "object",
      "properties": {
        "script_id": {
          "type": "string",
          "description": "The script identifier has a maximum length of 64 upper or lowercase alphanumeric characters, and can include underscores. It must not contain \"cisco\" and \"pulse\" prefixes. It must contain the suffix \"template\" if it is a template-based script and must not contain the suffix \"template\" if it is not a template-based script."
        },
        "script": {
          "type": "string",
          "description": "Kapacitor TICKScript."
        }
      }
    },
    "define_dashboard": {
      "type": "object",
      "properties": {
        "body": {
          "type": "object",
          "description": "Grafana dashboard definition in JSON format"
        }
      }
    },
    "define_sensor_group": {
      "type": "object",
      "properties": {
        "cadence": {
          "type": "integer",
	  "$ref": "#/definitions/cadence"
        },
        "sensor_paths": {
          "type": "object",
          "properties": {
            "sensor_path": {
              "type": "array",
              "items": {
                "properties": {
                  "path_id": {
                    "type": "string",
                    "description": "Path identifier"
                  }
                }
              }
            }
          }
        }
      }
    },
    "field": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name of a sensor path field"
        },
        "tag": {
          "type": "boolean",
          "description": "Flag indicates if field 'name' is a Tag. The default is false."
        }
      },
      "required": [
        "name"
      ]
    },
    "path": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "KPI sensor path"
        },
        "cadence": {
          "type": "object",
          "$ref": "#/definitions/cadence"
        },
        "spec": {
          "type": "object",
          "properties": {
            "fields": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/field"
              }
            }
          }
        }
      }
    },
    "cadence": {
      "type": "object",
      "properties": {
        "default": {
          "type": "integer",
          "$ref": "#/definitions/cadence"
        },
        "min": {
          "type": "integer",
          "description": "The minimum cadence at which telemetry is performed. The system expects it to be defined at all times."
        },
        "max": {
          "type": "integer",
          "description": "The maximum cadence at which telemetry is performed. The system expects it to be defined at all times."
        },
        "increment": {
          "type": "integer",
          "description": "The increment to apply between cadence limits. If set to 0, it can be ignored."
        }
      },
      "required": [
        "default",
        "min",
        "max"
      ],
      "example": {
        "default":   5,
        "min":       1,
        "max":       30,
        "increment": 1
      }
    },
    "script": {
      "type": "object",
      "properties": {
        "script_id": {
          "type": "string",
          "description": "TICKscript ID, in this format: <script name>.tick"
        },
        "script": {
          "type": "string",
          "readOnly": true,
          "description": "Script"
        },
        "parameters": {
          "type": "object",
          "$ref": "#/definitions/parameters"
        }
      }
    },
    "parameter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Internal name of the KPI parameter used in the backend, used in other REST calls."
        },
        "type": {
          "type": "string",
          "description": "The type of parameter (for example: string, int, float)."
        },
        "value": {
          "type": "string",
          "description": "The value of the parameter"
        },
        "display_name": {
          "type": "string",
          "description": "The human-readable name of the KPI parameter, to be displayed to the user."
        },
        "possible_values": {
          "type": "array",
          "description": "Array of strings that define the possible vaues for this parameter. If this array is not empty, it should be used as the list of options to be displayed to the user for this parameter.",
          "items": {
            "type": "string"
          }
        }
      },
      "example": {
        "name": "alert_threshold",
        "type": "float",
        "value": "2.0",
        "display_name": "Alert Threshold",
        "possible_values": ["MINOR", "MAJOR", "WARNING", "CRITICAL"]
      }
    },
    "parameters": {
      "type": "object",
      "properties": {
        "parameter": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/parameter"
          }
        }
      },
      "example": {
        "parameter": [
          {
            "name": "alert_threshold",
            "type": "float",
            "value": "40.0",
            "display_name": "Alert Threshold"
          },
          {
            "name": "alert_crit_time",
            "type": "float",
            "value": "0.0",
            "display_name": "Alert Critical Time"
          }
        ]
      }
    },
    "dashboard": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "Type of reference to Grafana dashboard"
        },
        "value": {
          "type": "string",
          "description": "Reference to Grafana Dashboard"
        }
      },
      "required": [
        "type",
        "value"
      ],
      "example": {
        "type": "jsonfile",
        "value": "Pulse-cpu-utilization-summary.json"
      }
    },
    "dashboards": {
      "type": "object",
      "properties": {
        "dashboards": {
          "type": "object",
          "properties": {
            "dashboard": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/dashboard"
              }
            }
          }
        }
      },
      "example": {
        "dashboard": [
          {
            "type": "jsonfile",
            "value": "Pulse-cpu-utilization-summary.json"
          },
          {
            "type": "jsonfile",
            "value": "Pulse-cpu-utilization-raw.json"
          }
        ]
      }
    },
    "error": {
      "type": "object",
      "properties": {
        "error": {
          "type": "string",
          "description": "Error message"
        }
      }
    },
    "pulseAlertSummaryGroup": {
      "type": "object",
      "properties": {
        "levels": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseAlertView"
          }
        }
      }
    },
    "pulseAlertSummaryTS": {
      "type": "object",
      "properties": {
        "level": {
          "type": "string",
          "title": "The level of an alert"
        },
        "alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseTimeCount"
          },
          "title": "The count of alerts by time"
        }
      },
      "title": "AlertSummaryTS is a time series that contains a count of alerts by time for each alert level."
    },
    "pulseAlertView": {
      "type": "object",
      "properties": {
        "level": {
          "type": "string",
          "title": "A valid alert level (for example: CRITICAL,WARNING,INFO,OK)"
        },
        "alert": {
          "type": "integer",
          "format": "int64",
          "title": "The count of alerts"
        }
      }
    },
    "pulseAlertsDevReq": {
      "type": "object",
      "properties": {
        "devices": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are returned."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "top_devices": {
          "type": "boolean",
          "format": "boolean",
          "title": "Optional flag indicating if the API should return a list of Devices sorted by the number of alerts."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records.  For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data, so that during pagination, data is returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsDevReq defines the parameters used in the POST request to get the Device View of alerts for devices.",
      "example": {
  "devices": [
    "RouterSFO"
  ],
  "kpis": [
    ""
  ],
  "levels": [
    ""
  ],
  "top_devices": true,
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "5",
  "offset": "0"
      }
    },
    "pulseAlertsDevTagsReq": {
      "type": "object",
      "properties": {
        "device_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are returned."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "top_devices": {
          "type": "boolean",
          "format": "boolean",
          "title": "Optional flag indicating if the API should return a list of Devices sorted by the number of alerts."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsDevTagsReq defines the parameters used in the POST request to get Device View of alerts for Device Tags",
      "example": {
  "device_tags": [
    "cli"
  ],
  "kpis": [
    ""
  ],
  "levels": [
    ""
  ],
  "top_devices": true,
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "5",
  "offset": "0"
}
    },
    "pulseAlertsKpiDevReq": {
      "type": "object",
      "properties": {
        "devices": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are considered."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "top_kpis": {
          "type": "boolean",
          "format": "boolean",
          "title": "Optional flag indicating if the API should return a list of Devices sorted by the number of alerts."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsKpiReq defines the parameters used in the POST request to get the KPI view of alerts for Devices",
      "example": {
  "devices": [
    "RouterSFO"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "top_kpis": true,
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "20",
  "offset": "0"
}
    },
    "pulseAlertsKpiDevTagsReq": {
      "type": "object",
      "properties": {
        "device_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are considered."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "top_kpis": {
          "type": "boolean",
          "format": "boolean",
          "title": "Optional flag indicating if the API should return a list of Devices sorted by the number of alerts."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsKpiDevTagsReq defines the parameters used in the POST request to get the KPI view of alerts for Device Tags.",
      "example": {
  "device_tags": [
    "cli"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "top_kpis": true,
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "20",
  "offset": "0"
}
    },
    "pulseAlertsResp": {
      "type": "object",
      "properties": {
        "device_alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseDeviceAlerts"
          },
          "title": "Contains a Device-specific view of alerts filtered by various parameters passed to the API. It is populated when a Device view of alerts is requested for Devices or Device Tags."
        },
        "kpi_alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseKpiAlerts"
          },
          "title": "Contains a KPI-specific view of alerts filtered by various parameters passed to the API. It is populated when a KPI view of alerts is requested for Devices or Device Tags."
        },
        "series": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseAlertSummaryTS"
          },
          "title": "Contains a time series of alert summary by levels"
        },
        "start_time": {
          "type": "string",
          "format": "int64",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        },
        "time_series": {
          "type": "string",
          "format": "byte",
          "title": "Contains raw time series without any aggregation\nstring time_series = 5;\nmap \u003cstring, google.protobuf.Any\u003e time_series = 5;\ngoogle.protobuf.Value time_series = 5;\ngoogle.protobuf.Struct time_series = 5;\nbytes time_series = 5;"
        }
      }
    },
    "pulseAlertsDevViewResp": {
      "type": "object",
      "properties": {
        "device_alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseDeviceAlerts"
          },
          "title": "Contains a Device-specific view of alerts filtered by various parameters passed to the API. It is populated when a Device view of alerts is requested for Devices or Device Tags"
        },
        "start_time": {
          "type": "string",
          "format": "int64",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      }
    },
    "pulseAlertsKpiViewResp": {
      "type": "object",
      "properties": {
        "kpi_alerts": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseKpiAlerts"
          },
          "title": "Contains a KPI-specific view of alerts filtered by various parameters passed to the API. It is populated when a KPI view of alerts is requested for Devices or Device Tags."
        },
        "start_time": {
          "type": "string",
          "format": "int64",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      }
    },
    "pulseAlertsSeriesResp": {
      "type": "object",
      "properties": {
        "series": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/pulseAlertSummaryTS"
          },
          "title": "Contains time series of alert summary by levels."
        }
      }
    },
    "pulseAlertsTimeSeriesResp": {
      "type": "object",
      "properties": {
        "time_series": {
          "type": "string",
          "format": "byte",
          "title": "Contains raw time series without any aggregation.\nstring time_series = 5;\nmap \u003cstring, google.protobuf.Any\u003e time_series = 5;\ngoogle.protobuf.Value time_series = 5;\ngoogle.protobuf.Struct time_series = 5;\nbytes time_series = 5;"
        }
      }
    },
    "pulseAlertsSeriesDtlReq": {
      "type": "object",
      "properties": {
        "devices": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are considered."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsSeriesDtlReq defines the parameters used in the POST request to get the raw time series of alerts for Devices.",
      "example": {
  "devices": [
    "RouterSFO"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "20",
  "offset": "0"
}
    },
    "pulseAlertsSeriesDtlTagsReq": {
      "type": "object",
      "properties": {
        "device_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are considered."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional start time of the Time period in terms of minutes(m) or hours(h)\ne.g if time_ago = 4 then the API will consider alerts that came in prior to last 4hours\nDefault is now"
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsSeriesDtlTagsReq defines the parameters used in the POST request to get the raw time series of alerts for Device Tags",
      "example": {
  "device_tags": [
    "cli"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "20",
  "offset": "0"
  }
    },
    "pulseAlertsSeriesLevelsDevReq": {
      "type": "object",
      "properties": {
        "devices": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are returned."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "groupby": {
          "type": "string",
          "title": "Specifies the groupby time interval when the user needs an aggregated count of alerts per interval in a time series format. For example: If groupby=30m and time_interval=12h, the API will aggregate alerts into one group for every 30 minutes during the 12-hour period. You can pass groupby only when Series is passed as true."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call.."
        }
      },
      "title": "AlertsSeriesLevelsDevReq defines the parameters used in the POST request to get the time series of count of alerts by levels per time interval for Devices. Used by bar charts in the Pulse UI.",
      "example": {
  "devices": [
    "RouterSFO"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "time_ago": "0m",
  "time_interval": "6h",
  "groupby": "30m",
  "limit": "20",
  "offset": "0"
}
    },
    "pulseAlertsSeriesLevelsDevTagsReq": {
      "type": "object",
      "properties": {
        "device_tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of Devices for which alerts are being requested. If nothing is passed, alerts for all Devices are returned."
        },
        "kpis": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of KPI IDs (kpi_id) used to filter the alerts."
        },
        "levels": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Optional comma-separated list of alert levels, used to filter the alerts. Valid values include CRITICAL, WARNING, INFO, OK."
        },
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "groupby": {
          "type": "string",
          "title": "Specifies the groupby time interval when the user needs an aggregated count of alerts per interval in a time series format. For example: If groupby=30m and time_interval=12h, the API will aggregate alerts into one group for every 30 minutes during the 12-hour period. You can pass groupby only when Series is passed as true."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        },
        "start_time": {
          "type": "string",
          "description": "The timestamp returned by the API, to be used in subsequent calls for pagination. In all subsequent calls to this API, the starttime should be sent back in the request parameters. In a time series DB, where data is continuously being written, the startTime helps preserve the data set of a query by fixing the starttime of the data. During pagination, this allows data to be returned from the same data set that was returned in the first API call."
        }
      },
      "title": "AlertsSeriesLevelsDevTagsReq defines the parameters used in the POST request to get time series of count of alerts by levels per time interval\nfor Device Tags. Used by bar charts in the Pulse UI.",
      "example": {
  "device_tags": [
    "cli"
  ],
  "kpis": [
    "pulse_cpu_threshold"
  ],
  "levels": [
    ""
  ],
  "time_ago": "0m",
  "time_interval": "6h",
  "groupby": "30m",
  "limit": "20",
  "offset": "0"
  }
    },
    "pulseAlertsSeriesSummaryReq": {
      "type": "object",
      "properties": {
        "time_ago": {
          "type": "string",
          "title": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "title": "Specifies the length of the time period, in terms of minutes (m) or hours (h). For example: If timeInterval=12h, the query will aggregate all alerts for the past 12 hours. The default is 1h."
        },
        "limit": {
          "type": "string",
          "title": "Specifies the limit on the number of Devices to return in a single request. For example: If limit=4 then the API will return alerts for up to 4 Devices. The default is 50."
        },
        "offset": {
          "type": "string",
          "title": "For pagination, specify the offset while fetching records. For example: If the limit is 10, then in the first API call the offset will be 0, in the second call offset=10, in the third call offset=20, and so on."
        }
      },
      "title": "AlertsSeriesSummaryReq defines the parameters used in the POST request to get the raw time series of a summary view of Impacted Devices and Impacted KPIs (Crosswork UI landing page).",
      "example": {
  "time_ago": "0m",
  "time_interval": "1d",
  "limit": "20",
  "offset": "0"
}
    },
    "pulseDeviceAlerts": {
      "type": "object",
      "properties": {
        "device_id": {
          "type": "string",
          "title": "The ID of the Device for which alerts are returned"
        },
        "device_type": {
          "type": "string",
          "title": "The Device type for the specified Device"
        },
        "device_IP": {
          "type": "string",
          "title": "The IP address of the specified Device"
        },
        "impact_score": {
          "type": "integer",
          "format": "int64",
          "title": "The impact score value of the specified Device. The current implementation of impact_score derivation logic is as follows: \nImpact Score  = 4 * (# of critical alerts) + 3 * (# of major alerts) + 2 * (# of warning alerts) + 1 * (# of info alerts)."
        },
        "total_alerts": {
          "type": "integer",
          "format": "int64",
          "title": "The total number of alerts for the specified Device"
        },
        "summary": {
          "$ref": "#/definitions/pulseAlertSummaryGroup",
          "title": "Contains the count of alerts broken down by levels"
        }
      }
    },
    "pulseKpiAlerts": {
      "type": "object",
      "properties": {
        "kpi_id": {
          "type": "string",
          "title": "The ID of the KPI for which alerts are returned"
        },
        "kpi_name": {
          "type": "string",
          "title": "The name of the specified KPI"
        },
        "kpi_type": {
          "type": "string",
          "title": "The KPI type for the specified KPI"
        },
        "impact_score": {
          "type": "integer",
          "format": "int64",
          "title": "The impact score value of the specified KPI. The current implementation of impact_score derivation logic is as follows: \nImpact Score  = 4 * (# of critical alerts) + 3 * (# of major alerts) + 2 * (# of warning alerts) + 1 * (# of info alerts)"
        },
        "total_alerts": {
          "type": "integer",
          "format": "int64",
          "title": "The total number of alerts for the specified Device"
        },
        "devices": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "A list of Devices that are currently alerting for the specified KPIs."
        },
        "summary": {
          "$ref": "#/definitions/pulseAlertSummaryGroup",
          "title": "Contains the count of alerts, broken down by levels."
        }
      }
    },
    "pulseTimeCount": {
      "type": "object",
      "properties": {
        "time": {
          "type": "string",
          "format": "uint64",
          "title": "The timestamp to use when counting alerts"
        },
        "alert": {
          "type": "integer",
          "format": "int64",
          "title": "A count of the alerts at the specified time"
        }
      },
      "title": "A time series that contains a count of alerts by time"
    },
    "transaction": {
      "type": "object",
      "properties": {
        "txid": {
          "type": "integer",
          "description": "Transaction identifier (64-bit integer)."
        },
        "start_time": {
          "type": "string",
          "description": "Start time of the transaction. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
        },
        "end_time": {
          "type": "string",
          "description": "End time of transaction. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
        },
        "state": {
          "type": "string",
          "description": "State of the transaction. Values are 'Failed', 'Partial', 'Processing', 'Queued', and 'Success'."
        },
        "error": {
          "type": "string",
          "description": "Error message, if any, of the transaction."
        },
        "method": {
          "type": "string",
          "description": "The HTTP method. Values are 'DELETE', 'POST', and 'PUT'."
        },
        "url": {
          "type": "string",
          "description": "The Request URL"
        },
        "request": {
          "type": "object",
          "description": "Request body in JSON format."
        },
        "tasks": {
          "type": "object",
          "properties": {
            "task": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "uuid": {
                    "type": "string",
                    "description": "UUID"
                  },
                  "kpi_id": {
                    "type": "string",
                    "description": "KPI identifier. The ID can have a maximum length of 64 upper or lowercase alphanumeric characters, and can include underscores. It must not contain \"cisco\" or \"pulse\" prefixes."
                  },
                  "device_id": {
                    "type": "string",
                    "description": "Device identifier."
                  },
                  "start_time": {
                    "type": "string",
                    "description": "Start time of task. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
                  },
                  "end_time": {
                    "type": "string",
                    "description": "End time of task. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
                  },
                  "state": {
                    "type": "string",
                    "description": "State of task. Values are 'Failed', 'Processing', 'Queued', and 'Success'."
                  },
                  "operation": {
                    "type": "string",
                    "description": "Operation values are 'Create', 'Delete', and 'Update'."
                  },
                  "error": {
                    "type": "string",
                    "description": "Error message, if any, of the task."
                  },
                  "subtasks": {
                    "type": "object",
                    "properties": {
                      "subtask": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "subtask_id": {
                              "type": "string",
                              "description": "Subtask identifier"
                            },
                            "start_time": {
                              "type": "string",
                              "description": "Start time of the subtask. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
                            },
                            "end_time": {
                              "type": "string",
                              "description": "End time of the subtask. Unix time, formatted like this example: \"2017-10-30T14:53:33.967154-07:00\"."
                            },
                            "state": {
                              "type": "string",
                              "description": "State of the subtask. Values are 'Failed', 'Processing', 'Queued', and 'Success'."
                            },
                            "error": {
                              "type": "string",
                              "description": "Error message, if any, of the subtask."
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "template": {
      "type": "object",
      "properties": {
        "template_id": {
          "type": "string",
          "description": "Template identifier"
        },
        "template_name": {
          "type": "string",
          "description": "The template display name"
        },
        "script": {
          "type": "string",
          "description": "Kapacitor TICKScript"
        }
      }
    },
    "templates": {
      "type": "object",
      "properties": {
        "templates": {
          "type": "object",
          "properties": {
            "template": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/template"
              }
            }
          }
        }
      }
    },
    "transactions": {
      "type": "object",
      "properties": {
        "transactions": {
          "type": "object",
          "properties": {
            "transaction": {
              "type": "array",
              "description": "A transaction is a DELETE, POST, or PUT of KPI and Device.",
              "items": {
                "$ref": "#/definitions/transaction"
              }
            }
          }
        }
      }
    },
    "remediate": {
      "type": "object",
      "properties": {
        "device_id": {
          "type": "string",
          "description": "The ID of the Device for which remediation is being requested."
        },
        "kpi_id": {
          "type": "string",
          "description": "The ID of the KPI for which remediation is being requested."
        },
        "levels": {
          "type": "object",
          "properties": {
            "level": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/level"
              }
            }
          }
        },
        "time_ago": {
          "type": "string",
          "description": "Optional. Specifies the start time of the time period, in terms of minutes (m) or hours (h). For example: If time_ago=4h then the API will consider alerts that came in prior to the last four hours. The default is now."
        },
        "time_interval": {
          "type": "string",
          "description": "Specifies the length of the time period in terms of hours (h) or minutes  (m). For example: If timeInterval=12h, the query will consider all alerts for the past 12 hours. The default is 1h."
        }
      }
    },
    "level": {
      "type": "object",
      "properties": {
        "level": {
          "type": "string",
          "description": "Alert levels to be considered for remediation. Valid values include CRITICAL, WARNING, INFO, OK."
        }
      }
    },
    "link_kpi": {
      "type": "object",
      "properties": {
        "kpi_id": {
          "type": "string",
          "description": "ID of the KPI to which remediation is being associated."
        },
        "kpi_name": {
          "type": "string",
          "description": "Name of the KPI to which remediation is being associated."
        },
        "remediation": {
          "$ref": "#/definitions/remediation",
          "title": "Contains parameters for remediating the KPI"
        }
      }
    },
    "link": {
      "type": "object",
      "properties": {
        "kpi": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/link_kpi"
          }
        }
      },
      "example": {
        "kpi": [{
          "kpi_id": "pulse_interface_flap_detector",
          "kpi_name": "Interface flap detection",
          "remediation": {
            "url": "/crosswork/nca/v1/mopjobs",
            "body": {
              "mop_id": "router_op_interface",
              "mop_name": "Interface State change",
              "hosts": "{{ index .Content `Producer` }}",
              "execution_params": {
                "admin_state": "down",
                "if_names": ["{{ index .Content `interface-name` }}"],
                "provider": "Nso",
                "collection_type": "telemetry",
                "mop_timeout": "1h",
                "check_mode": false
              }
            }
          }
        }
        ]}
    },
    "remediation": {
      "type": "object",
      "properties": {
        "URL": {
          "type": "string",
          "description": "URL for the Change Automation Playbook for this remediation."
        },
        "body": {
          "type": "string",
          "format": "byte",
          "description": "Bytes array containing the Change Automation playbook parameters for this remediation."
        }
      },
      "example": {
        "device_id": "RouterSFO",
        "kpi_id": "pulse_interface_flap_detector",
        "levels": [
          {
            "level": "CRITICAL"
          },
          {
            "level": "INFO"
          }
        ],
        "time_ago": "0m",
        "time_interval": "5m"
      }
    }
  }
}
