{
  "swagger": "2.0",
  "info": {
    "title": "proto/alerting.proto",
    "description": "The alerting service is a logically centralized service implemented\nby one or more alerting instances, which provide applications with\nthe facility to:\n \n - Register interest in a time series for a batch of sensors from telemetry\n streams (including Model Driven Telemetry and SNMP) produced by a set of routers.\n \n - Manage Influx TICK scripts to compute functions over the raw or derived\n time series in real time on a continuous basis.\n \n - Organize, based on the outcome of the computations, the publishing of alerts to an Apache Kafka bus and a topic specified by the\n application.\n \n \nThe alerting service is exposed through the ROBOT messaging service\nalong with an HTTP interface exposed through ROBOT gateway services as\ndescribed below.\n \n \nThe alerting service is responsible for **setting up production of\ntelemetry streams** from the network as necessary to satisfy the\napplication's registered interest. The alerting service organizes\ntapping in to the raw telemetry streams wherever they are\nproduced, in order to extract data and **feed it in to the time\nseries database**. The alerting service interacts with the\nappropriate instances of Kapacitor to **install the TICK scripts**\nprovided by the application. Finally, the alerting service sets up\nadapting alerts and **publishes them on to the appropriate Kafka\nbus**. The role of the alerting service is to coordinate with the\ncollection and astack services to achieve the above on behalf of\napplications.\n \n \nThe application provides the following details in order to set up\nalerts supported by the underlying Influx/Kapacitor alerting stack:\n \n   - The sensors which contribute to the evaluation of when to alert/clear alerts in the form of a list of YANG paths (including YANG paths from autogenerated SNMP models), and the desired cadence (the stack will attempt to satisfy the desired cadence or faster).\n   - The devices or groups of devices the application cares about in the context of the alert being set up (group support is predicated on the collection service providing this support).\n   - The TICK scripts representing the processing of the time series attributes, generation of alerts and more (including generation of derived time series, watching for deadman, etc.).\n   - The topic which should be used to publish alerts arising from the registered alert, together with the key used to pick the topic partition (both embedded in the TICK itself).\n   \n \n\n\n ### Alerting and Scale-Out\n\n The alerting service attempts to serve ROBOT deployments of any scale as long\n as a number of constraints are honored. This section highlights deployment\n practices pertinent to scale, which should be taken into consideration when\n driving the alerting service. The figure below shows the components involved\n\n ![Alerting Service In ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/astack_api_highlevel.png?raw=true)\n in alerting at a high level. Taking the data path first, the alerting service\n is built to accommodate data collected from multiple distinct networks or\n subnetworks, and published to one or more independent pub/sub\n clusters. Data from these clusters is pulled to one or more astacks. Each astack\n is responsible for taking in raw data produced by the network under the control\n of the collection service, and transforming that data into published alerts\n according to specifications provided by applications.\n\n SCALE RULE: The data pipeline, from production of telemetry to consumption of\n alerts, can be routed through various parallel paths (that is, it can be scaled out). The atom\n of data (that is, the volume of data which can not be split any further) is the\n data which must be processed by one constraint specification. In API terms,\n this means that we have to have at least one path between production and consumption,\n which can accommodate all the data which needs to be processed by a single\n AlertControl and set of TICK scripts. Beyond that, the alerting system can\n scale out horizontally to accommodate an unlimited number of AlertControls,\n TICK scripts and application instances. Note that the last leg of delivery\n (that is, between astack and application) can also be scaled out horizontally with\n multiple instances of an application. This leg of scale out relies on using\n Kafka partitions and multiple consumers in a consumer group.\n\n The SCALE RULE can be put another way: There is no limit to the number of\n applications and alerts setup which is imposed by the vertical scale of any\n of the components, but there is a limit to the volume of data handled by \n a single AlertControl. That limit is imposed by the capacity of the astack\n associated with the AlertControl.\n\n It might be useful in future to treat downsampled sources of data as peers\n of raw data drawn from the network. This would allow for multistage data\n preperation for alerting.\n\n An astack, as shown in the figure below, pulls data towards it using a fleet\n of pipeline instances subscribing to the pub/sub clusters and topics as\n instructed by collection service\n \n\n ![Alerting Service In ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/astack.png?raw=true)\n\n ### Logical Model For Alerting Service\n \n At the heart of the alerting service model is a time series database. The\n logical time series database can hold time series for any sensor from any\n part of the network and is shared by many applications.\n \n When an application registers an alert specification (that is, an opaque set of\n constraints on sensor values over time which determine whether an\n application should be notified or not), the application also registers which\n sensors, **from which network devices**, contribute to the alert\n specification. The alerting service needs to know which sources the\n application is interested in order to make sure that the shared time series\n database is populating and retaining the requested time series.\n \n Conversely, because the logical time series database is a shared database,\n the application **must** not assume that the only sources for the sensor\n time series are the sources it has registered. Filtering in the alert\n specification (for examples, a TICK script using `WHERE`) is crucial. Looking at the\n diagram below, `measurement 2` may well contain data from network devices\n beyond what App1 has registered an interest in. This is because App2 has also\n registered an interest in `measurement 2` and the sources may be different\n from App1. \n \n ![Logical Model for Alerting Service in ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/logical_model.png?raw=true)\n \n The best way to think of this is that, by default, all sensors from across the\n network have corresponding time series in the time series database, and that\n ROBOT optimises movement of data by dropping series which have no\n corresponding registered interest from applications.\n \n In other words, the starting point for the logical model of the alerting\n service is as shown in the diagram above: a logical time series database\n which contains time series for all possible sensors from every possible\n location in the network.\n \n Of course, the reality is different. A time series for a sensor for a\n network device will **not** be populated unless some application has\n registered the sensor/network device as one which is of interest. This is\n represented in the next diagram.\n \n ![Logical Model for Alerting Service in\n ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/logical_model_opt.png?raw=true)\n \n Note how the time series database no longer collects `measurement 4` at all\n because there is no party which is interested in `measurement 4` at this\n point in time. Also notice how it is only a subset of network devices which\n are contributing to the rest of the `measurement`s. The subset is determined\n by the union of registrations of the applications.\n \n One final twist to the model of the alerting service as exposed to the\n applications, is that the implementation of what looked like a single TSDB\n cluster, is in fact a distributed set of clusters. In the diagram below,\n notice how `App1` has set up an alert specification (that is, `AlertControl` in\n API terms) which uses measurements 1 and 2. It also registers another\n alert specification which uses measurement 3. Notice how the second alert\n specification may be serviced by astack 2, as opposed to astack 1 which is\n where the first alert spec was set up. This allows the implementation to\n spread the load across astacks as it sees fit. A single alert specification\n will always be serviced by a single astack cluster. \n  \n ![Logical Model for Alerting Service in ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/logical_model_opt_dist.png?raw=true)\n \n ### Driving the API\n \n The key players in this API are the Application (App), and the Alerting\n Service (AlertSvc). The primary resource is the AlertControl object.\n \n A single AlertControl object is created and maintained in response to a\n request by the App and is the atom of an alerting setup. A single\n AlertControl object represents the application's desire to process time\n series derived from a batch of sensors, from a set of routers, where the\n (possibly quite sophisticated) processing of the time series against some\n set of conditions, might result in notifications published on a Apache Kafka\n topic as specified by the application.\n \n The typical lifecycle of an alert is described using the sequence diagram\n below.\n \n ![Alerting Service In ROBOT](https://github3.cisco.com/ROBOT/astack/blob/develop/api/alert_full_lifecycle.png?raw=true)\n \n Time series for the batch or sensors from the set of routers associated with\n an AlertControl object are brought to the TSDB/Alerting machinery of a\n single astack. The AlertControl object is setup by the App to maintain a\n batch of TICK scripts. The alerting service ensures that the TICK scripts\n are run on Kapacitor which is subscribed to the time series associated with an\n AlertControl object. Furthermore, the alerting service ensures that any\n alerts triggered by the TICK scripts are adapted and published to the\n requested Kafka topic/key indicated by the application to a pub/sub\n cluster picked by the alerting service.\n \n\n ### TICK Script Format\n\n TICK scripts need to honor some minimal format constraints in order to\n ensure that the alerts generated can be routed by the notifiers within the\n astack to the appropriate topic. The two constraints are that a named\n variable POST_TO should be used as the argument to `post` in alerts.\n\n The second is to ensure that the `.id()` field, as shown in the sample alert\n below, would always start with a suffix of the form:\n\n ```\n\t\t\"id\":\"topic,key,appid,{{ .TaskName }},...\".\n ```\n\n Notifiers use the prefix to extract the topic to which to publish. They\n also use the prefix to extract the key to use, in the case where the key is pertinent\n to picking a partition on the pub/sub cluster. The rest of the fields are used\n for visualisation purposes; metrics are exported by the notifier which allow\n for per-application, per-alert control visualisation.\n\n Here is an example of an alert generated with the pertinent ID prefix being:\n\n\t\t\"id\":\"allinterfaceup,spine22,myappid,myappid_interface_watcher\n\n The full notification looks like:\n       \n     {\"id\":\"allinterfaceup,spine22,myappid,myappid_interface_watcher,TenGigE0/0/0/21,spine22\",\"message\":\"im-state-admindown\",\"details\":\"na\",\"time\":\"2017-01-11T16:47:50.531Z\",\"duration\":0,\"level\":\"CRITICAL\",\"data\":{\"series\"\\\n       :[{\"name\":\"Cisco-IOS-XR-pfi-im-cmd-oper:interfaces/interface-xr/interface\",\"tags\":{\"Producer\":\"\\spine22\",\"interface-name\":\"TenGigE0/0/0/21\"},\"columns\":[\"time\",\"line-state\"],\"values\":[[\"2017-01-11T16:47:50.531Z\",\"im-state-admindown\"]]}]}}\n \n Note that a single AlertControl can support multiple TICK scripts, resulting in\n muliple Tasks and TaskIDs. The TaskID names associated with an AlertControl\n are of the form \u003cApplicationID\u003e_\u003cAppNameForAlert\u003e_\u003cindex\u003e where index is the\n position of the script in the list of scripts provided.\n\n ### Template Support\n\n As part of the configuration of an AlertControl, it is possible to provide a\n sequence of complete TICK scripts to apply, or a sequence of (template, variable set)\n pairs. The only difference between the two is the manner in which the TICK script\n is installed into Kapacitor. There is no difference to the function implemented by\n the resulting task. Stream templates only are supported.\n\n The necessary APIs are provided to manage templates and are documented below.\n\n Status: API provided, implementation pending.\n\n ### Implementation Notes\n \n A primary goal of the alerting service is to hide the complexity of\n coordinating geographically distributed, independent, horizontally scalable\n collection and astack services, as shown in the diagram above. In\n reality, underpinning the logical model described above is a system\n where different very loosely coupled clusters might be collecting\n content from different regions of the network. Equally a number of\n astack deployments in different regions of the network might be at the\n disposal of the alerting service as shown in figures above.\n \n At the same time, the alerting service exposes the full power of the\n Influx/Kapacitor stack, and does not impose up-front constraints around\n which permutation of time series can be inspected when evaluating alerts.\n Neither does it limit how to compute alerts from derived series.\n   \n Authorization and authentication is not specified explicitly in this API. A\n common authorization and authentication pattern is implemented through an\n API gateway service and is documented in one place.\n\n For all APIs, users should consider that there are three possible outcomes:\n a success indication (in which case the service guarantees to not forget the\n request without attempting to service it), a failure indication (in which case \n the request did not stick), or a failure to complete the request (in which case\n the user does not know what state has persisted). To that end, the user should\n either replay the request (idempotent requests help), or, alternatively, the user\n should clean up all possible states generated by the request.\n\n APIs are batched (e.g. POST/PATCH), and asynchronous (except for GET). In\n those cases the immediate resturn is simply an ACCEPT or REJECT. Requests\n are accepted liberally, and may fail. Status can be returned with GET.\n A GET will always return the current state, which may not\n include pending requests. An indication of pending requests is provided\n along with the state of the alerting control. \n\n ### Availability of Alerting Service Control Plane\n\n Multiple coordinating service instances can be run to service requests on\n the same NATS Streaming topic. These coordinating instances are invisible\n to the application, and have at their disposal a number of astacks to\n deploy alert requests too.\n\n Note: Bits of functionality required to support\n dynamic rebalancing of application to cluster, sophisticated selection of\n astack, and retry for failures is designed but not as yet implemented.\n\n On top of that, a ROBOT instance can support a number of clusters of\n alerting services (e.g. A,B for incremental feature deployment, per version\n of service, per region, and so on). In this case, the choice of which cluster to\n use is visible and within the control of the application",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/alerts": {
      "get": {
        "summary": "Retrieve a specific registered alert associated with the application.\nThis alerts endpoint returns an *AlertControl* object as\nregistered with the alerting service by application with applicationID.\nThe argument passed in is the ApplicationAlertControlID.\nArgument returned is AlertControl itself.",
        "operationId": "Get",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingAlertControl"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance associated with the Alert.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "AlertControlID",
            "description": "ApplicationControlID is the identity of the alert as reported back by\nthe alerting service, and reflects the AppNameForAlert.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "delete": {
        "summary": "Delete a specific registered alert associated with the\napplication. The alerts endpoint requests deletion of\nan *AlertControl* object as registered with the alerting\nservice.\nThe argument passed in is the ApplicationAlertControlID. \nThe returned argument Result indicates whether the deletion\nrequest was accepted or not.",
        "operationId": "Delete",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingResult"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance associated with the Alert.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "AlertControlID",
            "description": "ApplicationControlID is the identity of the alert as reported back by\nthe alerting service, and reflects the AppNameForAlert.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "post": {
        "summary": "Register a batch of AlertControl objects. An\nAlertControl object captures the application's desire to\ncollect and process a set of time series for device\nsensors, evaluate those series against some set of\nconstraints, and where (on transition in and out of\nsatisfying the constraints) alerts would be triggered and\ndelivered to the application. If an AlertControl already\nexists (as identified by AppID, AppNameForAlert) then the\nexisting AlertControl will be discarded, and a new one\nwill be set up with the new configuration (that is, replaced).\nNote that the allocated stack may be different in this case,\n(unlike in the case when an existing AlertControl is\npatched).",
        "description": "The argument passed in is the PostArg.\nThe argument returned is the AlertControlConfigResultBatch.",
        "operationId": "Post",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingAlertControlConfigResultBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/alertingPostArg"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "patch": {
        "summary": "Patch a batch of registered alerts associated with the application.\nNote that the only parts of a request which can be patched are the\nscripts associated with the Alert (including enable/disable).\nOn patch, the alerts are withdrawn and reapplied to the same\nastack.\nThe argument passed in is the PatchArg.\nThe argument returned is the AlertControlPatchResultBatch",
        "operationId": "Patch",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingAlertControlPatchResultBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/alertingPatchArg"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/alerts/all": {
      "get": {
        "summary": "Retrieve batch. Not yet implemented. Use Get.",
        "operationId": "GetAll",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingAlertControlBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance interacting\nwith the alerting service. In ROBOT Skeleton applications, this\nwould typically be derived from the ID field in the\nConductorState object managed entirely by the skeleton itself\nand obtained from the configuration (etcd or file), and possibly\nmodified by orchestrator through ENVIRONMENT substitution.\nNote that tasks and templates installed in Kapacitor will\ninclude the '\u003cApplicationID\u003e_' prefix.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "delete": {
        "summary": "Delete batch. Not yet implemented. Use Delete.",
        "operationId": "DeleteAll",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingAlertControlConfigBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance interacting\nwith the alerting service. In ROBOT Skeleton applications, this\nwould typically be derived from the ID field in the\nConductorState object managed entirely by the skeleton itself\nand obtained from the configuration (etcd or file), and possibly\nmodified by orchestrator through ENVIRONMENT substitution.\nNote that tasks and templates installed in Kapacitor will\ninclude the '\u003cApplicationID\u003e_' prefix.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/alerts/forced": {
      "delete": {
        "summary": "Delete a specific registered alert associated with the\napplication. The alerts endpoint requests deletion of\nan *AlertControl* object as registered with the alerting\nservice.\nThe argument passed in is the ApplicationAlertControlID.\nThe returned argument Result indicates whether the deletion\nrequest was accepted or not.",
        "operationId": "ForceDelete",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingResult"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance associated with the Alert.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "AlertControlID",
            "description": "The ApplicationControlID is the identity of the alert as reported back by\nthe alerting service, and reflects the AppNameForAlert.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/templates": {
      "get": {
        "summary": "Retrieve a specific registered template associated with the application.\nThis templates endpoint returns a TemplateControl object as\nregistered with the alerting service by application with applicationID.\nThe argument passed in is the TemplateControlID.\nThe argument returned is TemplateControl itself.",
        "operationId": "GetTemplate",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingTemplateControl"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance associated with the Alert.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "AppNameForTemplate",
            "description": "The TemplateControlID is the identity of the template as reported back by\nthe alerting service, and coined by the application.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "delete": {
        "summary": "Delete a specific registered template associated with the\napplication. A template should only be removed when no\nalerts require it. Any existing alerts will be rendered stale \nif they depend on the template. The only way to redress such\nan issue would be to POST the template and re-POST/PATCH the alerts.\t\t\n\t\t\t\nThe argument passed in is the ApplicationAlertControlID.\nThe returned argument Result indicates whether the deletion\nrequest was accepted or not.",
        "operationId": "DeleteTemplate",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingResult"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance associated with the Alert.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "AppNameForTemplate",
            "description": "The TemplateControlID is the identity of the template as reported back by\nthe alerting service, and coined by the application.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "post": {
        "summary": "Register a batch of AlertTemplate objects. A \nTemplate is a TICK template which will be installed\non one or more astack Kapacitors as required. If a \nTemplate already exists (as identified by AppID,\nAppNameForTemplate), then the existing template will be\ndiscarded, and a new one will be set up. Note that all\nTasks using the template must be POST/PATCHED in between\nthe POST of a template, and the DELETE.",
        "description": "The argument passed in is the TemplatePostArg.\nThe argument returned is the TemplateControlConfigResultBatch.",
        "operationId": "PostTemplate",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingTemplateControlConfigResultBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/alertingTemplatePostArg"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "patch": {
        "summary": "Patch a batch of registered alert templates associated with\nthe application.\nThe argument passed in is the TemplatePatchArg.\nThe argument returned is the TemplateControlConfigResultBatch.",
        "operationId": "PatchTemplate",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingTemplateControlConfigResultBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/alertingTemplatePatchArg"
            }
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    },
    "/templates/all": {
      "get": {
        "summary": "Retrieve batch. Not yetimplemented. Use Get.",
        "operationId": "GetTemplateAll",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingTemplateControlBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance interacting\nwith the alerting service. In ROBOT Skeleton applications, this\nwould typically be derived from the ID field in the\nConductorState object managed entirely by the skeleton itself\nand obtained from the configuration (etcd or file), and possibly\nmodified by orchestrator through ENVIRONMENT substitution.\nNote that tasks and templates installed in Kapacitor will\ninclude the '\u003cApplicationID\u003e_' prefix.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      },
      "delete": {
        "summary": "Delete batch. Not yet implemented. Use Delete.",
        "operationId": "DeleteTemplateAll",
        "responses": {
          "200": {
            "description": "OK. The request was successful. The result is contained in the response body",
            "schema": {
              "$ref": "#/definitions/alertingTemplateControlConfigBatch"
            }
          }
        },
        "parameters": [
          {
            "name": "ApplicationID",
            "description": "The ApplicationID identifies the application instance interacting\nwith the alerting service. In ROBOT Skeleton applications, this\nwould typically be derived from the ID field in the\nConductorState object managed entirely by the skeleton itself\nand obtained from the configuration (etcd or file), and possibly\nmodified by orchestrator through ENVIRONMENT substitution.\nNote that tasks and templates installed in Kapacitor will\ninclude the '\u003cApplicationID\u003e_' prefix.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "Alerts"
        ]
      }
    }
  },
  "definitions": {
    "AlertScriptTaskTypeEnum": {
      "type": "string",
      "enum": [
        "STREAMTASK",
        "BATCHTASK"
      ],
      "default": "STREAMTASK",
      "title": "- STREAMTASK: Stream Task Type\n - BATCHTASK: Batch Task Type"
    },
    "ResultResultValue": {
      "type": "string",
      "enum": [
        "REJECTED",
        "ACCEPTED"
      ],
      "default": "REJECTED",
      "description": "ResultValue indicated accept/reject for a request.\n\n - REJECTED: REJECTED indicates rejection to perform requested operation, and is accompanied by a Message.\n - ACCEPTED: ACCEPTED indicates that alerting service accepts a request to do work."
    },
    "StatusStateEnum": {
      "type": "string",
      "enum": [
        "NOTREADY",
        "READY",
        "FAILED"
      ],
      "default": "NOTREADY",
      "description": " - NOTREADY: NOTREADY indicates that initial setup of the object is in progress,\nor being retried.\n - READY: READY indicates that initial setup of the object is complete and\nastack and collection organised.\n - FAILED: An unrecoverable failure has occured, associated with the object."
    },
    "TemplateControlConfigTemplateTypeEnum": {
      "type": "string",
      "enum": [
        "STREAMTEMPLATE",
        "BATCHTEMPLATE"
      ],
      "default": "STREAMTEMPLATE",
      "title": "- STREAMTEMPLATE: Stream Template Type\n - BATCHTEMPLATE: Batch Template Type"
    },
    "TemplateLocationEntryTemplateStateEnum": {
      "type": "string",
      "enum": [
        "PENDING",
        "PROGRAMMED"
      ],
      "default": "PENDING",
      "description": " - PENDING: PENDING indicates that the template has not been installed on Kapacitor\nassociated with astack, or has failed on previous attempts, and has\nnot been successfully programmed yet. The StatusDescription field\nprovides some description of why template is not programmed on the\nastack Kapacitor.\n - PROGRAMMED: PROGRAMMED indicates, that from the perspective of alerting, the\nastack Kapacitor is correctly configured with the template."
    },
    "alertingAlertControl": {
      "type": "object",
      "properties": {
        "AlertControlID": {
          "type": "string"
        },
        "Config": {
          "$ref": "#/definitions/alertingAlertControlConfig"
        },
        "Status": {
          "$ref": "#/definitions/alertingStatus"
        },
        "SensorSet": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingSensor"
          }
        },
        "AlertFeed": {
          "$ref": "#/definitions/alertingPublishAlertFeed"
        },
        "Cluster": {
          "$ref": "#/definitions/alertingTSDBCluster"
        }
      }
    },
    "alertingAlertControlBatch": {
      "type": "object",
      "properties": {
        "Control": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControl"
          }
        }
      },
      "title": "AlertControlBatch is a batch of AlertControl objects"
    },
    "alertingAlertControlConfig": {
      "type": "object",
      "properties": {
        "AppNameForAlert": {
          "type": "string",
          "description": "AppNameForAlert is the unique (from the perspective of the app)\nname for an AlertControl. This will be associated with at most\none AlertControlID assigned by the alerting service."
        },
        "AppContext": {
          "type": "string",
          "description": "AppContext is opaque to the alerting service and pertinent to\nthe application."
        },
        "Scripts": {
          "$ref": "#/definitions/alertingAlertScriptSet",
          "description": "AlertScriptSet is the set of scripts including TICK scripts\nprovided by application."
        },
        "SensorConfig": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingSensorsFromDeviceSet"
          },
          "description": "SensorsFromDeviceSet describes the input data which should be\nbrought to the astack handling the scripts the producers\nproducing that data."
        }
      },
      "description": "AlertControlConfig is a configuration block for an AlertControl;\neverything required to communicate the configuration of an\nAlertControl including its input to the alerting service."
    },
    "alertingAlertControlConfigBatch": {
      "type": "object",
      "properties": {
        "Config": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControlConfig"
          },
          "description": "AlertControlConfigBatch is a batch of AlertControl configurations."
        }
      },
      "description": "AlertControlConfigBatch is a batch of AlertControl configurations."
    },
    "alertingAlertControlConfigResult": {
      "type": "object",
      "properties": {
        "Config": {
          "$ref": "#/definitions/alertingAlertControlConfig",
          "title": "AlertControlConfig object includes the application name\nand context associated with the request."
        },
        "AlertControlID": {
          "type": "string",
          "title": "AlertControlID is the alerting service allocated name for\nthe Alert. There are guaranteed to be at most one instance\nof AlertControlID for each AppID, AppNameForAlert."
        },
        "Result": {
          "$ref": "#/definitions/alertingResult",
          "description": "Result indicates whether the request was accepted or\nrejected. Work is done asynchronously, and this is not\na result of the work itself."
        }
      },
      "description": "AlertControlConfigResult indicates the AlertControlID associated\nwith the AlertControl requested, and also reflects whether \nthe AlertControl was accepted or rejected."
    },
    "alertingAlertControlConfigResultBatch": {
      "type": "object",
      "properties": {
        "Result": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControlConfigResult"
          }
        }
      },
      "description": "AlertControlConfigResultBatch carries a batch of results for\na batched request of AlertControl objects."
    },
    "alertingAlertControlPatch": {
      "type": "object",
      "properties": {
        "AlertControlID": {
          "type": "string",
          "description": "AlertControlID identifies the AlertControl in question.\nIf the AlertControl does not exist, or has not been\nsetup, then the update will be discarded, even if it is\naccepted on the front end."
        },
        "Scripts": {
          "$ref": "#/definitions/alertingAlertScriptSet",
          "description": "AlertScriptSet carries the new configuration."
        }
      },
      "description": "AlertControlPatch carries an update to the set of scripts and their\t\nenabled/disabled state associated with an AlertControl object.\nNote that a patch may be accepted and subsequently\ndiscarded if the AlertControl does not exist."
    },
    "alertingAlertControlPatchResult": {
      "type": "object",
      "properties": {
        "Patch": {
          "$ref": "#/definitions/alertingAlertControlPatch",
          "description": "AlertControlPatch identifies the AlertControl, and the new\nconfiguration request. Note that only the set\nof TICK scripts and their enabled state can be modified\nthrough a patch operation."
        },
        "Result": {
          "$ref": "#/definitions/alertingResult",
          "description": "Result indicates whether a patch was accepted or not, and why."
        }
      },
      "description": "AlertControlPatchResult indicates whether a patch has been accepted\nor rejected."
    },
    "alertingAlertControlPatchResultBatch": {
      "type": "object",
      "properties": {
        "Result": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControlPatchResult"
          }
        }
      },
      "description": "AlertControlPatchResultBatch is a batch or results for a batched\npatch request."
    },
    "alertingAlertScript": {
      "type": "object",
      "properties": {
        "Script": {
          "type": "string",
          "description": "Script is the TICK script itself. Note the format requirements\non the .id field, and the requirement of .post(POST_URL) in\nthe notes above."
        },
        "TemplatedScript": {
          "$ref": "#/definitions/alertingTemplatedAlertScript",
          "description": "TICK script specified in the form of a template name (only the\nsuffix - no need to specify \u003cApplicationID\u003e_ prefix)."
        },
        "Enable": {
          "type": "boolean",
          "format": "boolean",
          "description": "Enable determines whether the script is enabled or not. A common\npattern might involve installing the script as disabled in order\nto glean attributes like sensor content and pub/sub cluster\nidentity, and a subsequent PATCH operation to turn it on."
        },
        "TaskType": {
          "$ref": "#/definitions/AlertScriptTaskTypeEnum",
          "description": "TaskType specifies whether the TICK script takes a stream input or\nbatches of data produced by periodically running queries."
        },
        "Database": {
          "type": "string",
          "title": "Deprecated, use Dbrps below instead of\nDatabase name. If not specified, use default in alerting config.\nMust be specified together with Retention Policy."
        },
        "RetentionPolicy": {
          "type": "string",
          "description": "Deprecated, use Dbrps below instead of\nRetention Policy. If not specified, use default in alerting config.\nMust be specified together with Database name."
        },
        "ScriptName": {
          "type": "string",
          "description": "Unique name of this script. If it is not specified, it will be given\na unique name by alerting internally (alert control id + num).\nThis gives the client the option to control the Kapacitor task name."
        },
        "UpdateOnly": {
          "type": "boolean",
          "format": "boolean",
          "description": "Update script only.\nBy default it is false, which means alerting will create the task if \nit does not exist. If the task already exists, alerting will do\nnothing. \nIf UpdateOnly is true, alerting will check only two fields (Enable and      TemplatedScript.TemplatedAlertVars) and update their values."
        },
        "Dbrps": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingDBRP"
          },
          "title": "Array of Database/RetentionPolicy.\nBy default, the database/rp defined in alerting.conf will be included in\nthis array automatically. You just need to specify other dbrps here.\nThis replaces the previous single 'Database' and 'RetentionPolicy' fields."
        }
      },
      "description": "AlertScript carries a TICK script along with Enabled/Disabled state."
    },
    "alertingAlertScriptSet": {
      "type": "object",
      "properties": {
        "Script": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertScript"
          },
          "description": "Script is a collection of TICK scripts."
        }
      },
      "description": "AlertScriptSet is a collection of TICK scripts. This is one patchable\nattribute of AlertControl. Note that any time the AlertControl is\npatched old scripts are discarded and new one installed. The astack\nassigned to the Alert does NOT change on PATCH."
    },
    "alertingDBRP": {
      "type": "object",
      "properties": {
        "Database": {
          "type": "string",
          "title": "Database name. Must be specified together with Retention Policy."
        },
        "RetentionPolicy": {
          "type": "string",
          "description": "Retention Policy. Must be specified together with Database name."
        }
      }
    },
    "alertingDatabase": {
      "type": "object",
      "properties": {
        "Name": {
          "type": "string",
          "description": "Name is the name of the alerting database."
        },
        "RetentionPolicyID": {
          "type": "string",
          "description": "RetentionPolicyID is the name of the retention policy\nused by alerting in the TSDB database above."
        }
      },
      "description": "Database reflects the alerting database and retention policy in\nuse."
    },
    "alertingDeviceSet": {
      "type": "object",
      "properties": {
        "DeviceID": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "DeviceID uniquely identifies a device across ROBOT over time."
        },
        "DeviceGroupID": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The DeviceGroupID identifies a dynamic group of devices in ROBOT.\nDevice membership is expected to change. This service relies\non group membership services being available in ROBOT and\nthe collection service."
        }
      },
      "description": "The DeviceSet is a collection of device IDs or device group IDs identifying\none or more sets of devices. Note that managing the ID and group ID space is\noutside the scope of the alerting APIs."
    },
    "alertingPatchArg": {
      "type": "object",
      "properties": {
        "ApplicationID": {
          "type": "string",
          "description": "The ApplicationID is the identity of the application registering the AlertControl\nobjects which are to be patched. The applicationID namespace is outside the scope of\nthe alerting service."
        },
        "AlertControlPatch": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControlPatch"
          },
          "description": "AlertControlPatch objects represent the AlertControl objects\nbeing patched, together with the new configuration of those\nalerts."
        }
      },
      "description": "The PatchArg object is a batch of AlertControlPatch objects\ntogether with the application identity which owns the AlertControl\nobjects being patched."
    },
    "alertingPostArg": {
      "type": "object",
      "properties": {
        "ApplicationID": {
          "type": "string",
          "description": "The ApplicationID identifies the application instance registering alerts."
        },
        "AlertControlConfig": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingAlertControlConfig"
          },
          "description": "A set of AlertControlConfig objects describing the alerts required."
        }
      },
      "description": "The PostArg object reflects a posted request for a set of alerts, but an application."
    },
    "alertingPublishAlertFeed": {
      "type": "object",
      "properties": {
        "BusID": {
          "type": "string",
          "description": "The cluster ID for the pub/sub cluster where notifications\nwill be issued."
        }
      },
      "description": "PublishAlertFeed identifies a pub/sub cluster. Access details for\nthe cluster are outside the scope of the alerting service."
    },
    "alertingResult": {
      "type": "object",
      "properties": {
        "Result": {
          "$ref": "#/definitions/ResultResultValue",
          "description": "ResultValue indicates the acceptance or rejection of a request, not the outcome of the work itself."
        },
        "Message": {
          "type": "string",
          "description": "Message is a textual description of the reason for rejection, and can be safely passed on to the operator through logs or the application UI."
        }
      },
      "description": "Result is used to convey whether an operation (individual or in a batch)\nhas been accepted or not. A string message accompanies rejection to\nsupport troubleshooting."
    },
    "alertingSensor": {
      "type": "object",
      "properties": {
        "Config": {
          "$ref": "#/definitions/alertingSensorConfig"
        },
        "TimeSeries": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingSensorTimeSeries"
          }
        }
      },
      "description": "Sensor object associates a sensor config with the corresponding time series\nas they will be presented in TSDB."
    },
    "alertingSensorConfig": {
      "type": "object",
      "properties": {
        "SensorPath": {
          "type": "string",
          "title": "SensorPath is a YANG path to a leaf indicating an interest\nin the path. For example: This path could be a streaming telemetry path,\nor a YANG path derived from SNMP models."
        },
        "Cadence": {
          "type": "string",
          "format": "int64",
          "description": "The cadence in milliseconds. This data is passed on to the\ncollection service."
        }
      },
      "description": "The SensorConfig object reflects a sensor as identified by a YANG path,\nalong with the desired minimum cadence at which we would like to sample the sensor."
    },
    "alertingSensorTimeSeries": {
      "type": "object",
      "properties": {
        "Database": {
          "$ref": "#/definitions/alertingDatabase"
        },
        "Measurement": {
          "type": "string"
        },
        "Field": {
          "type": "string"
        },
        "Tag": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "description": "SensorTimeSeries object will convey the form of the time series in\nInfluxDB."
    },
    "alertingSensorsFromDeviceSet": {
      "type": "object",
      "properties": {
        "DeviceSet": {
          "$ref": "#/definitions/alertingDeviceSet",
          "title": "DeviceSet reflects a collection of devices."
        },
        "SensorConfig": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingSensorConfig"
          },
          "description": "SensorConfig reflects a group of sensors and their cadences."
        }
      },
      "description": "SensorsFromDeviceSet reflects a collection of SensorConfig objects\nand a set of devices (devices and groups of devices)."
    },
    "alertingStatus": {
      "type": "object",
      "properties": {
        "Description": {
          "type": "string",
          "description": "Description is a textual description which can be used in UIs/logging.\nDescription also includes a 'pending updated' note in case updates\nare enqueued for the object."
        },
        "ActiveSince": {
          "type": "string",
          "format": "int64",
          "description": "ActiveSince is the timestamp (in Unix epoch ns) from the\npoint this object was registered active in the alerting\nservice."
        },
        "RequestedSince": {
          "type": "string",
          "format": "int64",
          "description": "RequestedSince is the timestamp (in Unix epoch ns) from the point when\nthe object was requested."
        },
        "State": {
          "$ref": "#/definitions/StatusStateEnum",
          "description": "State reflects the object state."
        }
      },
      "description": "Status of an AlertControl or template object. The Status object reflects the\nstate of the AlertControl or template object from the perspective of the alerting\nservice."
    },
    "alertingTSDBCluster": {
      "type": "object",
      "properties": {
        "InfluxID": {
          "type": "string",
          "description": "InfluxID identifies the InfluxDB cluster."
        },
        "KapacitorID": {
          "type": "string",
          "description": "KapacitorID identifies the Kapacitor instance."
        },
        "Notifier": {
          "type": "string",
          "description": "Notifier identifies a notifier instance serving AlertControl."
        }
      },
      "description": "TSDBCluster is a collection of identities associated with an astack\ncluster. Access details for the cluster components are outside the scope\nof the alerting service."
    },
    "alertingTemplateControl": {
      "type": "object",
      "properties": {
        "Config": {
          "$ref": "#/definitions/alertingTemplateControlConfig",
          "title": "Configuration associated with the template."
        },
        "InstallSet": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingTemplateLocationEntry"
          },
          "description": "Status of the template object."
        },
        "LastUpdate": {
          "type": "string",
          "format": "int64",
          "title": "Timestamp indicating the last update (in Unix epoch ns)."
        }
      },
      "description": "TemplateControl is the object in alerting corresponding to a template\nused with astack Kapacitors."
    },
    "alertingTemplateControlBatch": {
      "type": "object",
      "properties": {
        "TemplateControl": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingTemplateControl"
          }
        }
      }
    },
    "alertingTemplateControlConfig": {
      "type": "object",
      "properties": {
        "AppNameForTemplate": {
          "type": "string",
          "description": "The name for template as determined by the application. Note\nthat the name as installed in Kapacitor will be disambiguated using\nthe derived form: \u003cApplicationID\u003e_\u003cAppNameForTemplate\u003e."
        },
        "TemplateScript": {
          "type": "string",
          "description": "The TemplateScript is the script installed as is on various Kapacitors\non demand."
        },
        "TemplateType": {
          "$ref": "#/definitions/TemplateControlConfigTemplateTypeEnum",
          "description": "TemplateType specifies whether the template is for a stream task or\nbatch task."
        }
      },
      "description": "TemplateControlConfig defines the name and content of a TICK template."
    },
    "alertingTemplateControlConfigBatch": {
      "type": "object",
      "properties": {
        "TemplateControlConfig": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingTemplateControlConfig"
          }
        }
      }
    },
    "alertingTemplateControlConfigResult": {
      "type": "object",
      "properties": {
        "Config": {
          "$ref": "#/definitions/alertingTemplateControlConfig",
          "description": "Config reflects the template config to which the result pertains."
        },
        "Result": {
          "$ref": "#/definitions/alertingResult",
          "description": "Result indicates whether the result was accepted or rejected."
        }
      },
      "description": "TemplateControlConfigResult object captures the immediate result\nassociated with an operation on a TemplateControl. The result indicates\nwhether each template config in the batch was accepted or rejected."
    },
    "alertingTemplateControlConfigResultBatch": {
      "type": "object",
      "properties": {
        "Result": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingTemplateControlConfigResult"
          }
        }
      },
      "description": "TemplatePostResultBatch is a collection of results associated with a batch\npost of templates."
    },
    "alertingTemplateLocationEntry": {
      "type": "object",
      "properties": {
        "KapacitorID": {
          "type": "string",
          "description": "The astack on which a template is targeted for installation."
        },
        "State": {
          "$ref": "#/definitions/TemplateLocationEntryTemplateStateEnum",
          "title": "The status of the template installation from the perspective of alerting"
        },
        "StatusDescription": {
          "type": "string",
          "description": "Message describing the current state, typically used to provide context\nin the case of failures."
        }
      },
      "description": "Reflects where templates are installed, and the state of that installation."
    },
    "alertingTemplatePatchArg": {
      "type": "object",
      "properties": {
        "ApplicationID": {
          "type": "string",
          "description": "The ApplicationID identifies the application instance patching templates."
        },
        "TemplateControlConfig": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/alertingTemplateControlConfig"
          },
          "description": "A set of TemplateConfig objects describing the template patch."
        }
      },
      "description": "TemplatePatchArg is a batch of template patch requests."
    },
    "alertingTemplatePostArg": {
      "type": "object",
      "properties": {
        "ApplicationID": {
          "type": "string",
          "description": "The ApplicationID identifies the application instance registering templates."
        },
        "TemplateControlConfigBatch": {
          "$ref": "#/definitions/alertingTemplateControlConfigBatch",
          "description": "A set of TemplateConfig objects describing the alerts required."
        }
      },
      "description": "TemplatePostArg is a batch of template requests."
    },
    "alertingTemplatedAlertScript": {
      "type": "object",
      "properties": {
        "AppNameForTemplate": {
          "type": "string",
          "description": "AppNameForTemplate is the name of the template (without the\n\u003cApplicationID\u003e_ prefix)."
        },
        "TemplatedAlertVars": {
          "type": "string",
          "title": "TemplatedAlertVars is a JSON string of the variables which will be\nsubstituted into the TICK script template. Note that this JSON\nscript will be unmarshalled using:\nhttps://godoc.org/github.com/influxdata/kapacitor/client/v1#Vars.UnmarshalJSON"
        }
      },
      "description": "TemplatedAlertScript is an AlertScript of the form (template name,\nvars)."
    }
  }
}
